//
// Copyright 2016 - 2020 (C). Alex Robenko. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#include <list>
#include <utility>

#include "comms/comms.h"
#include "cc_mqttsn/client/common.h"
#include "client.h"

CC_DISABLE_WARNINGS()
#include "cxxtest/TestSuite.h"
CC_ENABLE_WARNINGS()

#include "CommonTestClient.h"
#include "DataProcessor.h"

class ClientBasic : public CxxTest::TestSuite
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();
    void test10();
    void test11();
    void test12();
    void test13();
    void test14();
    void test15();
    void test16();
    void test17();
    void test18();
    void test19();
    void test20();
    void test21();
    void test22();
    void test23();
    void test24();
    void test25();
    void test26();
    void test27();
    void test28();
    void test29();
    void test30();
    void test31();
    void test32();
    void test33();
    void test34();
    void test35();
    void test36();
    void test37();
    void test38();
    void test39();
    void test40();
    void test41();
    void test42();
    void test43();
    void test44();
    void test45();
    void test46();

private:
    typedef DataProcessor::DataBuf DataBuf;

    typedef DataProcessor::AdvertiseMsg AdvertiseMsg;
    typedef DataProcessor::SearchgwMsg SearchgwMsg;
    typedef DataProcessor::GwinfoMsg GwinfoMsg;
    typedef DataProcessor::ConnectMsg ConnectMsg;
    typedef DataProcessor::ConnackMsg ConnackMsg;
    typedef DataProcessor::WilltopicreqMsg WilltopicreqMsg;
    typedef DataProcessor::WilltopicMsg WilltopicMsg;
    typedef DataProcessor::WillmsgreqMsg WillmsgreqMsg;
    typedef DataProcessor::WillmsgMsg WillmsgMsg;
    typedef DataProcessor::RegisterMsg RegisterMsg;
    typedef DataProcessor::RegackMsg RegackMsg;
    typedef DataProcessor::PublishMsg PublishMsg;
    typedef DataProcessor::PubackMsg PubackMsg;
    typedef DataProcessor::PubrecMsg PubrecMsg;
    typedef DataProcessor::PubrelMsg PubrelMsg;
    typedef DataProcessor::PubcompMsg PubcompMsg;
    typedef DataProcessor::SubscribeMsg SubscribeMsg;
    typedef DataProcessor::UnsubscribeMsg UnsubscribeMsg;
    typedef DataProcessor::PingreqMsg PingreqMsg;
    typedef DataProcessor::PingrespMsg PingrespMsg;
    typedef DataProcessor::DisconnectMsg DisconnectMsg;
    typedef DataProcessor::WilltopicupdMsg WilltopicupdMsg;
    typedef DataProcessor::WillmsgupdMsg WillmsgupdMsg;

    using TopicIdTypeVal = cc_mqttsn::field::TopicIdTypeVal;

    static const std::string DefaultClientId;
    static const unsigned DefaultAdvertisePeriod = 5 * 60 * 1000;
    static const unsigned MaxPeriod = std::numeric_limits<std::uint16_t>::max() * 1000;
    static const unsigned DefaultRetryTimeout = 5 * 1000;
    static const unsigned DefaultRetryCount = 3;
    static const unsigned char DefaultBroadcastRadius = 0;
    static const unsigned short DefaultKeepAlive = 60;

    typedef std::vector<std::uint8_t> DataSeq;

    struct ReportedMsgInfo
    {
        ReportedMsgInfo(const MqttsnMessageInfo& info)
          : m_topic((info.topic != nullptr) ? info.topic : std::string()),
            m_topicId(info.topicId),
            m_data(info.msg, info.msg + info.msgLen),
            m_qos(info.qos),
            m_retain(info.retain)
        {
        }

        std::string m_topic;
        MqttsnTopicId m_topicId = 0;
        std::vector<std::uint8_t> m_data;
        MqttsnQoS m_qos = MqttsnQoS_NoGwPublish;
        bool m_retain = false;
    };

    struct ReportedGwInfo
    {
        ReportedGwInfo(std::uint16_t id, MqttsnGwStatus status)
          : m_id(id),
            m_status(status)
        {
        }

        unsigned short m_id = 0U;
        MqttsnGwStatus m_status = MqttsnGwStatus_Invalid;
    };

    struct TestBasicState
    {
        unsigned m_nextRequestedTicks = 0;
        unsigned m_nextElapsedTicks = 0;
        DataSeq m_nextOutput;
        bool m_broadcast;
        std::list<ReportedMsgInfo> m_reportedMsgs;
        std::list<ReportedGwInfo> m_reportedGws;
        std::list<bool> m_reportedGwDisconnects;
        std::list<MqttsnAsyncOpStatus> m_reportedConnects;
        std::list<MqttsnAsyncOpStatus> m_reportedDisconnects;
        std::list<MqttsnAsyncOpStatus> m_reportedPublishes;
        std::list<std::pair<MqttsnAsyncOpStatus, MqttsnQoS> > m_reportedSubscribes;
        std::list<MqttsnAsyncOpStatus> m_reportedUnsubscribes;
        std::list<MqttsnAsyncOpStatus> m_reportedWillUpdates;
        std::list<MqttsnAsyncOpStatus> m_reportedWillTopicUpdates;
        std::list<MqttsnAsyncOpStatus> m_reportedWillMsgUpdates;
        std::list<MqttsnAsyncOpStatus> m_reportedSleeps;
        std::list<MqttsnAsyncOpStatus> m_reportedReconnects;
        std::list<MqttsnAsyncOpStatus> m_reportedMessageChecks;
    };

    template <typename TState>
    static void clearState(TState& state)
    {
        state = TState();
    }

    static void verifyNoOtherEvent(TestBasicState& state)
    {
        TS_ASSERT(state.m_reportedMsgs.empty());
        TS_ASSERT(state.m_reportedGws.empty());
        TS_ASSERT(state.m_reportedGwDisconnects.empty());
        TS_ASSERT(state.m_reportedConnects.empty());
        TS_ASSERT(state.m_reportedDisconnects.empty());
        TS_ASSERT(state.m_reportedPublishes.empty());
        TS_ASSERT(state.m_reportedSubscribes.empty());
        TS_ASSERT(state.m_reportedUnsubscribes.empty());
        TS_ASSERT(state.m_reportedWillUpdates.empty());
        TS_ASSERT(state.m_reportedWillTopicUpdates.empty());
        TS_ASSERT(state.m_reportedWillMsgUpdates.empty());
        TS_ASSERT(state.m_reportedSleeps.empty());
        TS_ASSERT(state.m_reportedReconnects.empty());
        TS_ASSERT(state.m_reportedMessageChecks.empty());
    }

    static void dataFromGw(CommonTestClient& client, const DataBuf& buf, const std::string& msg)
    {
        if (!msg.empty()) {
            TS_TRACE("--> " + msg);
        }
        client.inputData(&buf[0], buf.size());
    }

    typedef CommonTestClient::Ptr ClientPtr;
    static ClientPtr allocClient(TestBasicState* state = nullptr, DataProcessor* dataProc = nullptr)
    {
        auto ptr = CommonTestClient::alloc();
        assert(ptr);
        ptr->setRetryPeriod(DefaultRetryTimeout / 1000);
        ptr->setRetryCount(DefaultRetryCount);
        ptr->setBroadcastRadius(DefaultBroadcastRadius);

        ptr->setGwDisconnectReportCallback(
            [state]()
            {
                TS_TRACE("GW disconnect reported: ");
                if (state != nullptr) {
                    state->m_reportedGwDisconnects.push_back(true);
                }
            });

        ptr->setConnectCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Connect complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedConnects.push_back(val);
                }
            });

        ptr->setDisconnectCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Disconnect complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedDisconnects.push_back(val);
                }
            });

        ptr->setPublishCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Publish complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedPublishes.push_back(val);
                }
            });

        ptr->setSubsribeCompleteCallback(
            [state](MqttsnAsyncOpStatus val, MqttsnQoS qos)
            {
                TS_TRACE("Subscribe complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedSubscribes.push_back(std::make_pair(val, qos));
                }
            });

        ptr->setUnsubsribeCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Unsubscribe complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedUnsubscribes.push_back(val);
                }
            });

        ptr->setWillUpdateCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Will update complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedWillUpdates.push_back(val);
                }
            });

        ptr->setWillTopicUpdateCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Will topic update complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedWillTopicUpdates.push_back(val);
                }
            });

        ptr->setWillMsgUpdateCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Will msg update complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedWillMsgUpdates.push_back(val);
                }
            });

        ptr->setSleepCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Sleep complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedSleeps.push_back(val);
                }
            });

        ptr->setReconnectCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Reconnect complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedReconnects.push_back(val);
                }
            });

        ptr->setCheckMessagesCompleteCallback(
            [state](MqttsnAsyncOpStatus val)
            {
                TS_TRACE("Check messages complete with status: " + std::to_string((int)val));
                if (state != nullptr) {
                    state->m_reportedMessageChecks.push_back(val);
                }
            });

        ptr->setMessageReportCallback(
            [state](const MqttsnMessageInfo& msgInfo)
            {
                if (msgInfo.topic != nullptr) {
                    TS_TRACE(std::string("Received message with topic ") + msgInfo.topic);
                }
                else {
                    TS_TRACE(std::string("Received message with topic ID ") + std::to_string(msgInfo.topicId));
                }

                if (state != nullptr) {
                    state->m_reportedMsgs.push_back(msgInfo);
                }
            });
        ptr->setGwStatusReportCallback(
            [state](unsigned short gwId, MqttsnGwStatus status)
            {
                TS_TRACE(std::string("GW info reported: id=") + std::to_string(gwId) + "; status=" + std::to_string(status));
                if (state != nullptr) {
                    state->m_reportedGws.push_back(ReportedGwInfo(gwId, status));
                }
            });

        if (state != nullptr) {
            ptr->setProgramNextTickCallback(
                [state](unsigned duration) noexcept
                {
                    state->m_nextRequestedTicks = duration;
                });

            ptr->setCancelNextTickCallback(
                [state]() noexcept -> unsigned
                {
                    return state->m_nextElapsedTicks;
                });

            ptr->setSendDataCallback(
                [state, dataProc](const std::uint8_t* buf, unsigned bufLen, bool broadcast)
                {
                    if (!state->m_nextOutput.empty()) {
                        TS_TRACE("ERROR: unconsumed message!!!");
                        if (dataProc != nullptr) {
                            processOutput(*state, *dataProc, state->m_broadcast);
                        }
                    }
                     assert(state->m_nextOutput.empty());
//                    TS_TRACE("Sending " + std::to_string(bufLen) + " bytes; broadcast=" + std::to_string(broadcast));
                    state->m_nextOutput.insert(state->m_nextOutput.end(), buf, buf + bufLen);
                    state->m_broadcast = broadcast;
                });

        }

        if (dataProc != nullptr)
        {
            dataProc->setSearchgwMsgReportCallback(
                [](const SearchgwMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- SEARCHGW");
                });

            dataProc->setConnectMsgReportCallback(
                [](const ConnectMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- CONNECT");
                });

            dataProc->setWilltopicMsgReportCallback(
                [](const WilltopicMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- WILLTOPIC");
                });

            dataProc->setWillmsgMsgReportCallback(
                [](const WillmsgMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- WILLMSG");
                });

            dataProc->setRegisterMsgReportCallback(
                [](const RegisterMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- REGISTER");
                });

            dataProc->setRegackMsgReportCallback(
                [](const RegackMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- REGACK");
                });

            dataProc->setPublishMsgReportCallback(
                [](const PublishMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBLISH");
                });

            dataProc->setPubackMsgReportCallback(
                [](const PubackMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBACK");
                });

            dataProc->setPubrecMsgReportCallback(
                [](const PubrecMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBREC");
                });

            dataProc->setPubrelMsgReportCallback(
                [](const PubrelMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBREL");
                });

            dataProc->setPubcompMsgReportCallback(
                [](const PubcompMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PUBCOMP");
                });

            dataProc->setSubscribeMsgReportCallback(
                [](const SubscribeMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- SUBSCRIBE");
                });

            dataProc->setUnsubscribeMsgReportCallback(
                [](const UnsubscribeMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- UNSUBSCRIBE");
                });

            dataProc->setPingreqMsgReportCallback(
                [](const PingreqMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PINGREQ");
                });

            dataProc->setPingrespMsgReportCallback(
                [](const PingrespMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- PINGRESP");
                });

            dataProc->setDisconnectMsgReportCallback(
                [](const DisconnectMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- DISCONNECT");
                });

            dataProc->setWilltopicupdMsgReportCallback(
                [](const WilltopicupdMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- WILLTOPICUPD");
                });

            dataProc->setWillmsgupdMsgReportCallback(
                [](const WillmsgupdMsg& msg)
                {
                    static_cast<void>(msg);
                    TS_TRACE("<-- WILLMSGUPD");
                });
        }

        return ptr;
    }

    static void doGwInfo(CommonTestClient& client, DataProcessor& dataProc, TestBasicState& state)
    {
        verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);

        clearState(state);
        static const std::uint8_t GwId = 5U;
        auto gwInfoData = dataProc.prepareGwinfoMsg(GwId);
        TS_ASSERT(!gwInfoData.empty());

        state.m_nextElapsedTicks = 1 * 1000;
        dataFromGw(client, gwInfoData, "GWINFO");
        verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_Available);
        verifyNoOtherEvent(state);
    }

    static const std::string& doConnect(
        CommonTestClient& client,
        DataProcessor& dataProc,
        TestBasicState& state,
        bool hasWill = false)
    {

        static const std::string ClientId = "test_client";
        static const std::string WillTopic("/this/is/will");
        static const std::vector<std::uint8_t> WillData{
            0x1, 0x2, 0x3, 0x4
        };
        static const MqttsnQoS WillQos = MqttsnQoS_AtLeastOnceDelivery;
        static const bool WillRetain = false;

        static const auto WillInfoCreateFunc =
            []() -> MqttsnWillInfo
            {
                auto willInfo = MqttsnWillInfo();
                willInfo.topic = WillTopic.c_str();
                willInfo.msg = &WillData[0];
                willInfo.msgLen = static_cast<decltype(willInfo.msgLen)>(WillData.size());
                willInfo.qos = WillQos;
                willInfo.retain = WillRetain;
                return willInfo;
            };

        static const MqttsnWillInfo WillInfo = WillInfoCreateFunc();
        TS_TRACE("Connecting...");
        state.m_nextElapsedTicks = 0;

        const MqttsnWillInfo* willInfo = nullptr;
        if (hasWill) {
            willInfo = &WillInfo;
        }
        auto result =
            client.connect(DefaultClientId.c_str(), DefaultKeepAlive, true, willInfo);
        TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
        verifySent_ConnectMsg(state, dataProc, ClientId, DefaultKeepAlive, true, willInfo != nullptr);
        TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
        verifyNoOtherEvent(state);

        clearState(state);

        if (hasWill) {
            auto willTopicReq = dataProc.prepareWilltopicreqMsg();
            dataFromGw(client, willTopicReq, "WILLTOPICREQ");
            verifySent_WilltopicMsg(state, dataProc, WillTopic, WillQos, WillRetain);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
            verifyNoOtherEvent(state);

            clearState(state);
            auto willMsgReq = dataProc.prepareWillmsgreqMsg();
            dataFromGw(client, willMsgReq, "WILLMSGREQ");
            verifySent_WillmsgMsg(state, dataProc, WillData);
            TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
            verifyNoOtherEvent(state);

            clearState(state);
        }

        auto connackMsg = dataProc.prepareConnackMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
        dataFromGw(client, connackMsg, "CONNACK");
        verifyCb_ReportedConnect(state, MqttsnAsyncOpStatus_Successful);
        TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
        verifyNoOtherEvent(state);
        return ClientId;
    }

    static void startClient(CommonTestClient& client)
    {
        auto result = client.start();
        TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    }

    static void doTopicRegister(
        CommonTestClient& client,
        DataProcessor& dataProc,
        TestBasicState& state,
        const std::string& topic,
        MqttsnTopicId topicId,
        std::uint16_t msgId)
    {
        clearState(state);
        auto registerMsg = dataProc.prepareRegisterMsg(topicId, msgId, topic);
        state.m_nextElapsedTicks = 1000;
        dataFromGw(client, registerMsg, "REGISTER");
        verifySent_RegackMsg(state, dataProc, topicId, msgId);
        verifyNoOtherEvent(state);
    }

    static void processOutput(
        const TestBasicState& state,
        DataProcessor& dataProc,
        bool broadcast = false)
    {
        TS_ASSERT(!state.m_nextOutput.empty());
        TS_ASSERT_EQUALS(state.m_broadcast, broadcast);
        dataProc.checkWrittenMsg(&state.m_nextOutput[0], state.m_nextOutput.size());
    }

    static void verifySent_SearchgwMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        unsigned short radius)
    {
        bool sent = false;
        auto oldCb = dataProc.setSearchgwMsgReportCallback(
            [&sent, radius](const SearchgwMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- SEARCHGW");
                TS_ASSERT_EQUALS(msg.field_radius().value(), radius);
            });

        processOutput(state, dataProc, true);
        TS_ASSERT(sent);

        dataProc.setSearchgwMsgReportCallback(std::move(oldCb));
    }

    static void verifySent_ConnectMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& clientId,
        unsigned short keepAlivePeriod,
        bool cleanSession,
        bool hasWill)
    {
        bool sent = false;
        auto oldCb = dataProc.setConnectMsgReportCallback(
            [&sent, &clientId, keepAlivePeriod, cleanSession, hasWill](const ConnectMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- CONNECT");
                TS_ASSERT_EQUALS(msg.field_flags().field_mid().getBitValue_CleanSession(), cleanSession);
                TS_ASSERT_EQUALS(msg.field_flags().field_mid().getBitValue_Will(), hasWill);
                TS_ASSERT_EQUALS(msg.field_protocolId().value(), 1);
                TS_ASSERT_EQUALS(msg.field_duration().value(), keepAlivePeriod);
                TS_ASSERT_EQUALS(msg.field_clientId().value(), clientId);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);

        dataProc.setConnectMsgReportCallback(std::move(oldCb));
    }

    static void verifySent_WilltopicMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& topic,
        MqttsnQoS qos,
        bool retain)
    {
        bool sent = false;
        auto oldCb = dataProc.setWilltopicMsgReportCallback(
            [&sent, &topic, qos, retain](const WilltopicMsg& msg)
            {
                typedef typename std::decay<decltype(msg)>::type MsgType;
                static_assert(MsgType::InterfaceOptions::HasReadIterator,
                    "Does not define read iterator");
                static_assert(!MsgType::ImplOptions::HasNoReadImpl,
                    "Does not implement read");
                static_assert(MsgType::ImplOptions::HasMsgType,
                    "Does not define message type");

                sent = true;
                TS_TRACE("<-- WILLTOPIC");
                TS_ASSERT_EQUALS(msg.field_willTopic().value(), topic);
                if (!topic.empty()) {
                    TS_ASSERT(msg.field_flags().doesExist());
                    TS_ASSERT_EQUALS(msg.field_flags().field().field_mid().getBitValue_Retain(), retain);
                    TS_ASSERT_EQUALS(CommonTestClient::transformQos(msg.field_flags().field().field_qos().value()), qos);
                }
                else {
                    TS_ASSERT(msg.field_flags().isMissing());
                }

            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setWilltopicMsgReportCallback(std::move(oldCb));
    }

    static void verifySent_WillmsgMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::vector<std::uint8_t>& data)
    {
        bool sent = false;
        auto oldCb = dataProc.setWillmsgMsgReportCallback(
            [&sent, &data](const WillmsgMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- WILLMSG");
                TS_ASSERT_EQUALS(msg.field_willMsg().value(), data);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setWillmsgMsgReportCallback(std::move(oldCb));
    }

    static std::uint16_t verifySent_RegisterMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& topic)
    {
        std::uint16_t msgId = 0;
        bool sent = false;
        auto oldCb = dataProc.setRegisterMsgReportCallback(
            [&msgId, &sent, &topic](const RegisterMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- REGISTER");
                TS_ASSERT_EQUALS(msg.field_topicId().value(), 0U);
                TS_ASSERT_EQUALS(msg.field_topicName().value(), topic);
                msgId = msg.field_msgId().value();
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setRegisterMsgReportCallback(std::move(oldCb));
        return msgId;

    }

    static void verifySent_RegackMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        MqttsnTopicId topicId,
        std::uint16_t msgId,
        cc_mqttsn::field::ReturnCodeVal retCode = cc_mqttsn::field::ReturnCodeVal::Accepted)
    {
        bool sent = false;
        auto oldCb = dataProc.setRegackMsgReportCallback(
            [&sent, topicId, msgId, retCode](const RegackMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- REGACK");

                TS_ASSERT_EQUALS(msg.field_topicId().value(), topicId);
                TS_ASSERT_EQUALS(msg.field_msgId().value(), msgId);
                TS_ASSERT_EQUALS(msg.field_returnCode().value(), retCode);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setRegackMsgReportCallback(std::move(oldCb));
    }

    static std::uint16_t verifySent_PublishMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        MqttsnTopicId topicId,
        const DataSeq& data,
        TopicIdTypeVal topicIdType,
        MqttsnQoS qos,
        bool retain,
        bool duplicate)
    {
        std::uint16_t msgId = 0;
        bool sent = false;
        auto oldCb = dataProc.setPublishMsgReportCallback(
            [&msgId, &sent, &data, topicId, topicIdType, qos, retain, duplicate](const PublishMsg& msg)
            {
                sent = true;

                TS_TRACE("<-- PUBLISH");
                TS_ASSERT_EQUALS(msg.field_flags().field_topicIdType().value(), topicIdType);
                TS_ASSERT_EQUALS(msg.field_flags().field_mid().getBitValue_Retain(), retain);
                TS_ASSERT_EQUALS(CommonTestClient::transformQos(msg.field_flags().field_qos().value()), qos);
                TS_ASSERT_EQUALS(msg.field_flags().field_high().getBitValue_Dup(), duplicate);
                TS_ASSERT_EQUALS(msg.field_topicId().value(), topicId);
                TS_ASSERT_EQUALS(msg.field_data().value(), data);

                msgId = msg.field_msgId().value();
                TS_TRACE("msg_id=" + std::to_string(msgId));
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPublishMsgReportCallback(std::move(oldCb));
        return msgId;
    }

    static void verifySent_PubackMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        MqttsnTopicId topicId,
        std::uint16_t msgId,
        cc_mqttsn::field::ReturnCodeVal retCode = cc_mqttsn::field::ReturnCodeVal::Accepted)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubackMsgReportCallback(
            [&sent, topicId, msgId, retCode](const PubackMsg& msg)
            {
                TS_TRACE("<-- PUBACK");
                sent = true;

                TS_ASSERT_EQUALS(msg.field_topicId().value(), topicId);
                TS_ASSERT_EQUALS(msg.field_msgId().value(), msgId);
                TS_ASSERT_EQUALS(msg.field_returnCode().value(), retCode);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubackMsgReportCallback(std::move(oldCb));
    }

    static void verifySent_PubrecMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        std::uint16_t msgId)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubrecMsgReportCallback(
            [&sent, msgId](const PubrecMsg& msg)
            {
                TS_TRACE("<-- PUBREC");
                sent = true;

                TS_ASSERT_EQUALS(msg.field_msgId().value(), msgId);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubrecMsgReportCallback(std::move(oldCb));
    }

    static void verifySent_PubrelMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        std::uint16_t msgId)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubrelMsgReportCallback(
            [&](const PubrelMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- PUBREL");
                TS_ASSERT_EQUALS(msg.field_msgId().value(), msgId);

            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubrelMsgReportCallback(std::move(oldCb));
    }

    static void verifySent_PubcompMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        std::uint16_t msgId)
    {
        bool sent = false;
        auto oldCb = dataProc.setPubcompMsgReportCallback(
            [&sent, msgId](const PubcompMsg& msg)
            {
                TS_TRACE("<-- PUBCOMP");
                sent = true;
                TS_ASSERT_EQUALS(msg.field_msgId().value(), msgId);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPubcompMsgReportCallback(std::move(oldCb));
    }

    static std::uint16_t verifySent_SubsribeMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& topic,
        MqttsnQoS qos,
        bool duplicate)
    {
        bool sent = false;
        std::uint16_t msgId = 0U;
        auto oldCb = dataProc.setSubscribeMsgReportCallback(
            [&sent, &msgId, &topic, qos, duplicate](const SubscribeMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- SUBSRIBE");

                bool shortName =
                    (topic.size() == 2U) &&
                    (topic.find_first_of("#+") == std::string::npos);

                if (shortName) {
                    TS_TRACE("Short topic detected");
                    TS_ASSERT_EQUALS(msg.field_flags().field_topicIdType().value(), TopicIdTypeVal::ShortTopicName);
                    TS_ASSERT(msg.field_topicId().doesExist());
                    TS_ASSERT(msg.field_topicName().isMissing());
                    TS_ASSERT_EQUALS(topic.size(), 2U);
                    auto topicId = ((std::uint16_t)topic[0] << 8) | ((std::uint8_t)topic[1]);
                    TS_ASSERT_EQUALS(msg.field_topicId().field().value(), topicId);
                }
                else {
                    TS_ASSERT_EQUALS(msg.field_flags().field_topicIdType().value(), TopicIdTypeVal::Normal);
                    TS_ASSERT(msg.field_topicId().isMissing());
                    TS_ASSERT(msg.field_topicName().doesExist());
                    TS_ASSERT_EQUALS(msg.field_topicName().field().value(), topic);
                }

                TS_ASSERT_EQUALS(transformQos(msg.field_flags().field_qos().value()), qos);
                TS_ASSERT_EQUALS(msg.field_flags().field_high().getBitValue_Dup(), duplicate);


                msgId = msg.field_msgId().value();
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setSubscribeMsgReportCallback(std::move(oldCb));
        return msgId;
    }

    static std::uint16_t verifySent_SubsribeMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        MqttsnTopicId topicId,
        MqttsnQoS qos,
        bool duplicate)
    {
        bool sent = false;
        std::uint16_t msgId = 0U;
        auto oldCb = dataProc.setSubscribeMsgReportCallback(
            [&sent, &msgId, topicId, qos, duplicate](const SubscribeMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- SUBSCRIBE");

                TS_ASSERT_EQUALS(msg.field_flags().field_topicIdType().value(), TopicIdTypeVal::PredefinedTopicId);
                TS_ASSERT_EQUALS(transformQos(msg.field_flags().field_qos().value()), qos);
                TS_ASSERT_EQUALS(msg.field_flags().field_high().getBitValue_Dup(), duplicate);
                TS_ASSERT(msg.field_topicId().doesExist());
                TS_ASSERT(msg.field_topicName().isMissing());
                TS_ASSERT_EQUALS(msg.field_topicId().field().value(), topicId);

                msgId = msg.field_msgId().value();
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setSubscribeMsgReportCallback(std::move(oldCb));
        return msgId;
    }

    static std::uint16_t verifySent_UnsubsribeMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& topic)
    {
        bool sent = false;
        std::uint16_t msgId = 0U;
        auto oldCb = dataProc.setUnsubscribeMsgReportCallback(
            [&sent, &msgId, &topic](const UnsubscribeMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- UNSUBSRIBE");

                bool shortName =
                    (topic.size() == 2U) &&
                    (topic.find_first_of("#+") == std::string::npos);

                if (shortName) {
                    TS_ASSERT_EQUALS(msg.field_flags().field_topicIdType().value(), TopicIdTypeVal::ShortTopicName);
                    TS_ASSERT(msg.field_topicId().doesExist());
                    TS_ASSERT(msg.field_topicName().isMissing());
                    TS_ASSERT_EQUALS(topic.size(), 2U);
                    auto topicId = ((std::uint16_t)topic[0] << 8) | ((std::uint8_t)topic[1]);
                    TS_ASSERT_EQUALS(msg.field_topicId().field().value(), topicId);
                }
                else {
                    TS_ASSERT_EQUALS(msg.field_flags().field_topicIdType().value(), TopicIdTypeVal::Normal);
                    TS_ASSERT(msg.field_topicId().isMissing());
                    TS_ASSERT(msg.field_topicName().doesExist());
                    TS_ASSERT_EQUALS(msg.field_topicName().field().value(), topic);
                }

                msgId = msg.field_msgId().value();
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setUnsubscribeMsgReportCallback(std::move(oldCb));
        return msgId;
    }

    static std::uint16_t verifySent_UnsubsribeMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        MqttsnTopicId topicId)
    {
        bool sent = false;
        std::uint16_t msgId = 0U;
        auto oldCb = dataProc.setUnsubscribeMsgReportCallback(
            [&sent, &msgId, topicId](const UnsubscribeMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- UNSUBSCRIBE");

                TS_ASSERT_EQUALS(msg.field_flags().field_topicIdType().value(), TopicIdTypeVal::PredefinedTopicId);
                TS_ASSERT(msg.field_topicId().doesExist());
                TS_ASSERT(msg.field_topicName().isMissing());
                TS_ASSERT_EQUALS(msg.field_topicId().field().value(), topicId);

                msgId = msg.field_msgId().value();
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setUnsubscribeMsgReportCallback(std::move(oldCb));
        return msgId;
    }

    static void verifySent_PingreqMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& clientId = std::string())
    {
        bool sent = false;
        auto oldCb = dataProc.setPingreqMsgReportCallback(
            [&sent, &clientId](const PingreqMsg& msg)
            {
                sent = true;
                TS_TRACE("<-- PINGREQ");
                TS_ASSERT_EQUALS(msg.field_clientId().value(), clientId);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPingreqMsgReportCallback(std::move(oldCb));
    }

    static void verifySent_PingrespMsg(
        const TestBasicState& state,
        DataProcessor& dataProc)
    {
        bool sent = false;
        auto oldCb = dataProc.setPingrespMsgReportCallback(
            [&sent](const PingrespMsg& msg)
            {
                sent = true;
                static_cast<void>(msg);
                TS_TRACE("<-- PINGRESP");
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setPingrespMsgReportCallback(std::move(oldCb));
    }

    static void verifySent_DisconnectMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        std::uint16_t duration = 0U)
    {
        bool sent = false;
        auto oldCb = dataProc.setDisconnectMsgReportCallback(
            [&sent, duration](const DisconnectMsg& msg)
            {
                sent = true;
                static_cast<void>(msg);
                TS_TRACE("<-- DISCONNECT");

                if (duration != 0) {
                    TS_ASSERT(msg.field_duration().doesExist());
                    TS_ASSERT_EQUALS(msg.field_duration().field().value(), duration);
                }
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setDisconnectMsgReportCallback(std::move(oldCb));
    }

    static void verifySent_WilltopicupdMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const std::string& topic,
        MqttsnQoS qos = MqttsnQoS(),
        bool retain = false)
    {
        bool sent = false;
        auto oldCb = dataProc.setWilltopicupdMsgReportCallback(
            [&sent, &topic, qos, retain](const WilltopicupdMsg& msg)
            {
                sent = true;
                static_cast<void>(msg);
                TS_TRACE("<-- WILLTOPICUPD");

                TS_ASSERT_EQUALS(msg.field_willTopic().value(), topic);
                if (!topic.empty()) {
                    TS_ASSERT_EQUALS(transformQos(msg.field_flags().field().field_qos().value()), qos);
                    TS_ASSERT_EQUALS(msg.field_flags().field().field_mid().getBitValue_Retain(), retain);
                    TS_ASSERT(msg.field_flags().doesExist());
                }
                else {
                    TS_ASSERT(msg.field_flags().isMissing());
                }
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setWilltopicupdMsgReportCallback(std::move(oldCb));
    }

    static void verifySent_WillmsgupdMsg(
        const TestBasicState& state,
        DataProcessor& dataProc,
        const DataSeq& data)
    {
        bool sent = false;
        auto oldCb = dataProc.setWillmsgupdMsgReportCallback(
            [&sent, &data](const WillmsgupdMsg& msg)
            {
                sent = true;
                static_cast<void>(msg);
                TS_TRACE("<-- WILLMSGUPD");

                TS_ASSERT_EQUALS(msg.field_willMsg().value(), data);
            });

        processOutput(state, dataProc);
        TS_ASSERT(sent);
        dataProc.setWillmsgupdMsgReportCallback(std::move(oldCb));
    }

    static void verifyCb_ReportedGw(
        TestBasicState& state,
        std::uint16_t gwId,
        MqttsnGwStatus status)
    {
        TS_ASSERT(!state.m_reportedGws.empty());
        if (state.m_reportedGws.empty()) {
            return;
        }

        auto& gw = state.m_reportedGws.front();
        TS_ASSERT_EQUALS(gw.m_id, gwId);
        TS_ASSERT_EQUALS(gw.m_status, status);
        state.m_reportedGws.pop_front();
    }

    static void verifyCb_ReportedMessage(
        TestBasicState& state,
        const std::string& topic,
        MqttsnTopicId topicId,
        const std::vector<std::uint8_t>& data,
        MqttsnQoS qos,
        bool retain)
    {
        TS_ASSERT(!state.m_reportedMsgs.empty());
        if (state.m_reportedMsgs.empty()) {
            return;
        }

        auto& msg = state.m_reportedMsgs.front();
        TS_ASSERT_EQUALS(msg.m_topic, topic);
        TS_ASSERT_EQUALS(msg.m_topicId, topicId);
        TS_ASSERT_EQUALS(msg.m_data, data);
        TS_ASSERT_EQUALS(msg.m_qos, qos);
        TS_ASSERT_EQUALS(msg.m_retain, retain);
        state.m_reportedMsgs.pop_front();
    }

    static void verifyCb_ReportedGwDisconnect(
        TestBasicState& state)
    {
        TS_ASSERT(!state.m_reportedGwDisconnects.empty());
        if (state.m_reportedGwDisconnects.empty()) {
            return;
        }

        state.m_reportedGwDisconnects.pop_front();
    }

    static void verifyCb_ReportedConnect(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedConnects.empty());
        if (state.m_reportedConnects.empty()) {
            return;
        }

        TS_ASSERT_EQUALS(state.m_reportedConnects.front(), status);
        state.m_reportedConnects.pop_front();
    }

    static void verifyCb_ReportedDisconnect(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedDisconnects.empty());
        if (state.m_reportedDisconnects.empty()) {
            return;
        }

        TS_ASSERT_EQUALS(state.m_reportedDisconnects.front(), status);
        state.m_reportedDisconnects.pop_front();
    }

    static void verifyCb_ReportedPublish(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedPublishes.empty());
        if (state.m_reportedPublishes.empty()) {
            return;
        }

        TS_ASSERT_EQUALS(state.m_reportedPublishes.front(), status);
        state.m_reportedPublishes.pop_front();
    }

    static void verifyCb_ReportedSubsribe(
        TestBasicState& state,
        MqttsnAsyncOpStatus status,
        MqttsnQoS qos)
    {
        TS_ASSERT(!state.m_reportedSubscribes.empty());
        if (state.m_reportedSubscribes.empty()) {
            return;
        }

        auto& elem = state.m_reportedSubscribes.front();

        TS_ASSERT_EQUALS(elem.first, status);
        TS_ASSERT_EQUALS(elem.second, qos);
        state.m_reportedSubscribes.pop_front();
    }

    static void verifyCb_ReportedUnsubsribe(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedUnsubscribes.empty());
        if (state.m_reportedUnsubscribes.empty()) {
            return;
        }

        auto& elem = state.m_reportedUnsubscribes.front();

        TS_ASSERT_EQUALS(elem, status);
        state.m_reportedUnsubscribes.pop_front();
    }

    static void verifyCb_ReportedWillUpdate(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedWillUpdates.empty());
        if (state.m_reportedWillUpdates.empty()) {
            return;
        }

        auto& elem = state.m_reportedWillUpdates.front();

        TS_ASSERT_EQUALS(elem, status);
        state.m_reportedWillUpdates.pop_front();
    }

    static void verifyCb_ReportedWillTopicUpdate(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedWillTopicUpdates.empty());
        if (state.m_reportedWillTopicUpdates.empty()) {
            return;
        }

        auto& elem = state.m_reportedWillTopicUpdates.front();

        TS_ASSERT_EQUALS(elem, status);
        state.m_reportedWillTopicUpdates.pop_front();
    }

    static void verifyCb_ReportedWillMsgUpdate(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedWillMsgUpdates.empty());
        if (state.m_reportedWillMsgUpdates.empty()) {
            return;
        }

        auto& elem = state.m_reportedWillMsgUpdates.front();

        TS_ASSERT_EQUALS(elem, status);
        state.m_reportedWillMsgUpdates.pop_front();
    }

    static void verifyCb_ReportedSleep(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedSleeps.empty());
        if (state.m_reportedSleeps.empty()) {
            return;
        }

        auto& elem = state.m_reportedSleeps.front();

        TS_ASSERT_EQUALS(elem, status);
        state.m_reportedSleeps.pop_front();
    }

    static void verifyCb_ReportedReconnect(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedReconnects.empty());
        if (state.m_reportedReconnects.empty()) {
            return;
        }

        auto& elem = state.m_reportedReconnects.front();

        TS_ASSERT_EQUALS(elem, status);
        state.m_reportedReconnects.pop_front();
    }

    static void verifyCb_ReportedMessageChecks(
        TestBasicState& state,
        MqttsnAsyncOpStatus status)
    {
        TS_ASSERT(!state.m_reportedMessageChecks.empty());
        if (state.m_reportedMessageChecks.empty()) {
            return;
        }

        auto& elem = state.m_reportedMessageChecks.front();

        TS_ASSERT_EQUALS(elem, status);
        state.m_reportedMessageChecks.pop_front();
    }

    static MqttsnQoS transformQos(cc_mqttsn::field::QosVal val)
    {
        return CommonTestClient::transformQos(val);
    }

    static cc_mqttsn::field::QosVal transformQos(MqttsnQoS val)
    {
        return CommonTestClient::transformQos(val);
    }
};

const std::string ClientBasic::DefaultClientId("test_client");

void ClientBasic::test1()
{
    auto client = allocClient();
    static_cast<void>(client);
}

void ClientBasic::test2()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    TS_TRACE("Started");
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    TS_TRACE("Tick");
    client->tick();
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    static const std::uint8_t GwId = 5U;
    auto gwInfoData = dataProc.prepareGwinfoMsg(GwId);
    TS_ASSERT(!gwInfoData.empty());

    assert(state.m_nextRequestedTicks == 0U);
    state.m_nextElapsedTicks = 1 * 1000;
    dataFromGw(*client, gwInfoData, "GWINFO");

    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_Available);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, MaxPeriod);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_TimedOut);
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    auto advertiseData = dataProc.prepareAdvertiseMsg(GwId, (DefaultAdvertisePeriod / 1000) + 1);
    TS_ASSERT(!advertiseData.empty());
    state.m_nextElapsedTicks = 1 * 1000;

    dataFromGw(*client, advertiseData, "ADVERTISE");
    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_Available);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, (DefaultAdvertisePeriod + 1000) * 3);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifyCb_ReportedGw(state, GwId, MqttsnGwStatus_TimedOut);
    verifySent_SearchgwMsg(state, dataProc, DefaultBroadcastRadius);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);
}

void ClientBasic::test3()
{
    // Connect without will
    DataProcessor dataProc;
    struct Test3State : public TestBasicState
    {
        MqttsnAsyncOpStatus m_connectionStatus = MqttsnAsyncOpStatus_Invalid;
    };

    Test3State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;

    client->setConnectCompleteCallback(
        [&](MqttsnAsyncOpStatus val)
        {
            // First connect is expected to be timed out
            TS_TRACE("Connect complete with status: " + std::to_string((int)val));
            TS_ASSERT_EQUALS(val, MqttsnAsyncOpStatus_NoResponse);

            client->setConnectCompleteCallback(
                [&](MqttsnAsyncOpStatus val2)
                {
                    TS_TRACE("Connect complete with status: " + std::to_string((int)val2));
                    TS_ASSERT_EQUALS(val2, MqttsnAsyncOpStatus_Successful);
                    state.m_connectionStatus = val2;
                });

            TS_TRACE("Reconnecting...");
            auto result2 =
                client->connect(ClientId.c_str(), KeepAlive, true, nullptr);

            TS_ASSERT_EQUALS(result2, MqttsnErrorCode_Success);
        });

    TS_TRACE("Connecting...");
    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, nullptr);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    clearState(state);
    client->tick();
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();

    // Timeout and new connect attempt is expected here

    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    clearState(state);
    auto connackMsg = dataProc.prepareConnackMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");

    TS_ASSERT_EQUALS(state.m_connectionStatus, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, KeepAlive * 1000);
    verifyNoOtherEvent(state);
}

void ClientBasic::test4()
{
    // Connect with will
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;
    static const std::string WillTopic("/this/is/will");
    static const std::vector<std::uint8_t> WillData{
        0x1, 0x2, 0x3, 0x4
    };
    static const MqttsnQoS WillQos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool WillRetain = false;

    TS_TRACE("Connecting...");
    auto willInfo = MqttsnWillInfo();
    willInfo.topic = WillTopic.c_str();
    willInfo.msg = &WillData[0];
    willInfo.msgLen = static_cast<decltype(willInfo.msgLen)>(WillData.size());
    willInfo.qos = WillQos;
    willInfo.retain = WillRetain;

    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, &willInfo);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);

    // Send ack message, check ignored
    state.m_nextElapsedTicks = 1000;
    auto connackMsg = dataProc.prepareConnackMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");
    // Ack must be ignored
    TS_ASSERT(state.m_nextOutput.empty())

    auto willTopicReq = dataProc.prepareWilltopicreqMsg();
    dataFromGw(*client, willTopicReq, "WILLTOPICREQ");
    verifySent_WilltopicMsg(state, dataProc, WillTopic, WillQos, WillRetain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick(); // Timeout is expected, new connect attempt

    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    dataFromGw(*client, willTopicReq, "WILLTOPICREQ");
    verifySent_WilltopicMsg(state, dataProc, WillTopic, WillQos, WillRetain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto willMsgReq = dataProc.prepareWillmsgreqMsg();
    dataFromGw(*client, willMsgReq, "WILLMSGREQ");
    verifySent_WillmsgMsg(state, dataProc, WillData);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    static const unsigned NextTicks = 1000;
    state.m_nextElapsedTicks = NextTicks;
    dataFromGw(*client, connackMsg, "CONNACK");

    // check connected
    verifyCb_ReportedConnect(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, (KeepAlive * 1000) - NextTicks);
    verifyNoOtherEvent(state);
}

void ClientBasic::test5()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    auto nextTicks = state.m_nextRequestedTicks;
    TS_ASSERT_EQUALS(nextTicks, DefaultKeepAlive * 1000);

    client->tick();
    verifySent_PingreqMsg(state, dataProc);
    verifyNoOtherEvent(state);

    clearState(state);
    static const unsigned NextTicks = 1000;
    state.m_nextElapsedTicks = NextTicks;
    auto pingRespMsg = dataProc.preparePingrespMsg();
    dataFromGw(*client, pingRespMsg, "PINGRESP");

    TS_ASSERT(state.m_nextOutput.empty());
    TS_ASSERT(!state.m_broadcast);

    nextTicks = state.m_nextRequestedTicks;
    TS_ASSERT_EQUALS(nextTicks, (DefaultKeepAlive * 1000) - NextTicks);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_PingreqMsg(state, dataProc);
    verifyNoOtherEvent(state);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick();
    verifySent_PingreqMsg(state, dataProc);
    verifyNoOtherEvent(state);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick();
    verifySent_PingreqMsg(state, dataProc);
    verifyNoOtherEvent(state);

    nextTicks = state.m_nextRequestedTicks;
    clearState(state);
    client->tick();
    verifyCb_ReportedGwDisconnect(state);
    verifyNoOtherEvent(state);
}

void ClientBasic::test6()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pingreqMsg = dataProc.preparePingreqMsg();
    dataFromGw(*client, pingreqMsg, "PINGREQ");
    verifySent_PingrespMsg(state, dataProc);
    verifyNoOtherEvent(state);

    clearState(state);
    auto disconnectMsg = dataProc.prepareDisconnectMsg();
    dataFromGw(*client, disconnectMsg, "DISCONNECT");
    verifyCb_ReportedGwDisconnect(state);
    verifyNoOtherEvent(state);
}

void ClientBasic::test7()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_DisconnectMsg(state, dataProc);
    verifyNoOtherEvent(state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);

    state.m_nextElapsedTicks = 1000;
    auto disconnectMsg = dataProc.prepareDisconnectMsg();
    dataFromGw(*client, disconnectMsg, "DISCONNECT");
    verifyCb_ReportedDisconnect(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test8()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_DisconnectMsg(state, dataProc);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_DisconnectMsg(state, dataProc);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_DisconnectMsg(state, dataProc);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();

    TS_ASSERT(state.m_nextOutput.empty());
    verifyCb_ReportedDisconnect(state, MqttsnAsyncOpStatus_NoResponse);
    verifyNoOtherEvent(state);
}

void ClientBasic::test9()
{
    DataProcessor dataProc;
    typedef TestBasicState Test9State;
    Test9State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string ClientId = "bla";
    static const unsigned short KeepAlive = 60;

    TS_TRACE("Connecting...");
    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(ClientId.c_str(), KeepAlive, true, nullptr);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_ConnectMsg(state, dataProc, ClientId, KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    bool cancelResult = client->cancel();
    TS_ASSERT(cancelResult);
    verifyCb_ReportedConnect(state, MqttsnAsyncOpStatus_Aborted);
    verifyNoOtherEvent(state);
}

void ClientBasic::test10()
{
    DataProcessor dataProc;
    typedef TestBasicState Test10State;
    Test10State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->disconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_DisconnectMsg(state, dataProc);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    state.m_nextElapsedTicks = 1000;
    bool cancelResult = client->cancel();
    TS_ASSERT(cancelResult);
    verifyCb_ReportedDisconnect(state, MqttsnAsyncOpStatus_Aborted);
    verifyNoOtherEvent(state);
}

void ClientBasic::test11()
{
    DataProcessor dataProc;
    typedef TestBasicState Test11State;
    Test11State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x0123;
    static const auto TopicIdType = TopicIdTypeVal::PredefinedTopicId;
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test12()
{
    DataProcessor dataProc;
    typedef TestBasicState Test12State;
    Test12State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);

    static const MqttsnTopicId TopicId = 0x0123;
    static const auto TopicIdType = TopicIdTypeVal::PredefinedTopicId;
    static const MqttsnQoS Qos = MqttsnQoS_NoGwPublish;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), MqttsnQoS_AtMostOnceDelivery, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotConnected);
    TS_ASSERT(state.m_reportedPublishes.empty());
    TS_ASSERT(state.m_nextOutput.empty());
    verifyNoOtherEvent(state);

    result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test13()
{
    DataProcessor dataProc;
    typedef TestBasicState Test13State;
    Test13State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x0123;
    static const auto TopicIdType = TopicIdTypeVal::PredefinedTopicId;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdTypeVal::PredefinedTopicId, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    auto msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId + 1, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    TS_ASSERT(state.m_nextOutput.empty()); // must be ignored
    verifyNoOtherEvent(state);

    clearState(state);
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test14()
{
    DataProcessor dataProc;
    typedef TestBasicState Test14State;
    Test14State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0xabcd;
    static const auto TopicIdType = TopicIdTypeVal::PredefinedTopicId;
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    static const unsigned NextTicks = 1000;
    state.m_nextElapsedTicks = NextTicks;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::InvalidTopicId);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_InvalidId);
    verifyNoOtherEvent(state);
}

void ClientBasic::test15()
{
    DataProcessor dataProc;
    typedef TestBasicState Test15State;
    Test15State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0xabcd;
    static const auto TopicIdType = TopicIdTypeVal::PredefinedTopicId;
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publishId(TopicId, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    auto msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 2000;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");
    verifySent_PubrelMsg(state, dataProc, msgId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_PubrelMsg(state, dataProc, msgId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    dataFromGw(*client, pubcompMsg, "PUBCOMP");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, (DefaultKeepAlive * 1000) - 1000);
    verifyNoOtherEvent(state);
}

void ClientBasic::test16()
{
    DataProcessor dataProc;
    typedef TestBasicState Test16State;
    Test16State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    static const MqttsnTopicId TopicId = 0x1234;
    clearState(state);

    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId + 1, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    TS_ASSERT(state.m_nextOutput.empty());
    verifyNoOtherEvent(state);

    regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;

    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000 - state.m_nextElapsedTicks);
    verifyNoOtherEvent(state);
}

void ClientBasic::test17()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_NoResponse);
    TS_ASSERT(state.m_nextOutput.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    client->reconnect();
    verifySent_ConnectMsg(state, dataProc, DefaultClientId, DefaultKeepAlive, false, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    auto connackMsg = dataProc.prepareConnackMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");
    verifyCb_ReportedReconnect(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test18()
{
    DataProcessor dataProc;
    typedef TestBasicState Test18State;
    Test18State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    TS_ASSERT(state.m_reportedPublishes.empty());
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    TS_ASSERT(state.m_reportedPublishes.empty());
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    static const unsigned NextTicks = 1000;
    state.m_nextElapsedTicks = NextTicks;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, (DefaultKeepAlive * 1000) - NextTicks);
    verifyNoOtherEvent(state);
}

void ClientBasic::test19()
{
    DataProcessor dataProc;
    typedef TestBasicState Test19State;
    Test19State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    static const unsigned NextTicks = 1000;
    state.m_nextElapsedTicks = NextTicks;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    TS_ASSERT(state.m_reportedPublishes.empty());
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, (DefaultKeepAlive * 1000) - NextTicks);
    verifyNoOtherEvent(state);

    clearState(state);
    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::InvalidTopicId);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, (DefaultKeepAlive * 1000) - NextTicks);
    verifyNoOtherEvent(state);
}

void ClientBasic::test20()
{
    DataProcessor dataProc;
    typedef TestBasicState Test20State;
    Test20State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    static const unsigned NextTicks = 1000;
    state.m_nextElapsedTicks = NextTicks;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    TS_ASSERT(state.m_reportedPublishes.empty());
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::InvalidTopicId);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_InvalidId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, (DefaultKeepAlive * 1000) - NextTicks);
    verifyNoOtherEvent(state);
}

void ClientBasic::test21()
{
    DataProcessor dataProc;
    typedef TestBasicState Test21State;
    Test21State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    static const unsigned NextTicks = 1000;
    state.m_nextElapsedTicks = NextTicks;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    client->cancel();
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Aborted);
    verifyNoOtherEvent(state);

    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    auto regackMsg = dataProc.prepareRegackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");
    verifySent_PubrelMsg(state, dataProc, msgId);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    client->cancel();
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Aborted);
    verifyNoOtherEvent(state);

    clearState(state);
    result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");
    verifySent_PubrelMsg(state, dataProc, msgId);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    dataFromGw(*client, pubcompMsg, "PUBCOMP");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, (DefaultKeepAlive * 1000) - NextTicks);
    verifyNoOtherEvent(state);
}

void ClientBasic::test22()
{
    DataProcessor dataProc;
    typedef TestBasicState Test22State;
    Test22State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("this/is/topic");
    static const std::uint16_t RegMsgId = 0x1234;
    static const MqttsnTopicId TopicId = 0x2222;
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    auto registerMsg = dataProc.prepareRegisterMsg(TopicId, RegMsgId, Topic);
    state.m_nextElapsedTicks = 1000;
    dataFromGw(*client, registerMsg, "REGISTER");
    verifySent_RegackMsg(state, dataProc, TopicId, RegMsgId);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdType, Qos, Retain, false);
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test23()
{
    DataProcessor dataProc;
    typedef TestBasicState Test23State;
    Test23State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic1("this/is/topic1");
    static const std::string Topic2("this/is/topic2");
    static const MqttsnTopicId Topic1Id = 0x1234;
    static const MqttsnTopicId Topic2Id = 0x4321;
    static const std::uint16_t RegMsgId = 0x2222;
    static const MqttsnQoS Qos1 = MqttsnQoS_ExactlyOnceDelivery;
    static const MqttsnQoS Qos2 = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->publish(Topic1, &Data[0], Data.size(), Qos1, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_RegisterMsg(state, dataProc, Topic1);
    verifyNoOtherEvent(state);

    clearState(state);
    static const unsigned NextTicks = 1000;
    state.m_nextElapsedTicks = NextTicks;
    auto regackMsg = dataProc.prepareRegackMsg(Topic1Id, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, regackMsg, "REGACK");
    msgId = verifySent_PublishMsg(state, dataProc, Topic1Id, Data, TopicIdTypeVal::Normal, Qos1, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    doTopicRegister(*client, dataProc, state, Topic2, Topic2Id, RegMsgId);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    auto pubrecMsg = dataProc.preparePubrecMsg(msgId);
    dataFromGw(*client, pubrecMsg, "PUBREC");
    verifySent_PubrelMsg(state, dataProc, msgId);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = NextTicks;
    auto pubcompMsg = dataProc.preparePubcompMsg(msgId);
    dataFromGw(*client, pubcompMsg, "PUBCOMP");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, (DefaultKeepAlive * 1000) - NextTicks);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->publish(Topic2, &Data[0], Data.size(), Qos2, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);

    msgId = verifySent_PublishMsg(state, dataProc, Topic2Id, Data, TopicIdTypeVal::Normal, Qos2, Retain, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(Topic2Id, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test24()
{
    DataProcessor dataProc;
    typedef TestBasicState Test24State;
    Test24State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x1234;
    static const std::uint16_t MsgId = 0x5555;
    static const auto TopicIdType = TopicIdTypeVal::PredefinedTopicId;
    static const auto Qos = cc_mqttsn::field::QosVal::AtMostOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, MsgId, Data, TopicIdType, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifyCb_ReportedMessage(state, std::string(), TopicId, Data, transformQos(Qos), Retain);
    TS_ASSERT(state.m_nextOutput.empty());
    verifyNoOtherEvent(state);

    static const char* Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, MsgId + 1, Data, TopicIdTypeVal::Normal, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifyCb_ReportedMessage(state, Topic, 0, Data, transformQos(Qos), Retain);
    TS_ASSERT(state.m_nextOutput.empty());
    TS_ASSERT(state.m_reportedMsgs.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId + 1, MsgId + 2, Data, TopicIdTypeVal::Normal, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubackMsg(state, dataProc, TopicId + 1, MsgId + 2, cc_mqttsn::field::ReturnCodeVal::InvalidTopicId);
    TS_ASSERT(state.m_reportedMsgs.empty());
    verifyNoOtherEvent(state);
}

void ClientBasic::test25()
{
    DataProcessor dataProc;
    typedef TestBasicState Test25State;

    Test25State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    static const std::uint16_t MsgId = 0x5555;
    static const auto TopicIdType = TopicIdTypeVal::Normal;
    static const auto Qos = cc_mqttsn::field::QosVal::AtLeastOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto expectedMsgId = MsgId;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubackMsg(state, dataProc, TopicId, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, 0, Data, transformQos(Qos), Retain);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubackMsg(state, dataProc, TopicId, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, 0, Data, transformQos(Qos), Retain); // Duplicate is reported for Qos 1
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    expectedMsgId = MsgId + 1;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubackMsg(state, dataProc, TopicId, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, 0, Data, transformQos(Qos), Retain);
    verifyNoOtherEvent(state);
}

void ClientBasic::test26()
{
    DataProcessor dataProc;
    typedef TestBasicState Test26State;

    Test26State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic = "/this/is/topic";
    static const std::uint16_t RegMsgId = 0x1222;
    static const MqttsnTopicId TopicId = 0x1234;

    clearState(state);
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    static const std::uint16_t MsgId = 0x5555;
    static const auto TopicIdType = TopicIdTypeVal::PredefinedTopicId;
    static const auto Qos = cc_mqttsn::field::QosVal::ExactlyOnceDelivery;
    static const bool Retain = false;
    static const std::vector<std::uint8_t> Data = {
        0x01, 0x02, 0x03, 0x04, 0xab, 0xcd, 0xef
    };

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto expectedMsgId = MsgId;
    auto publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, false);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubrecMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    dataFromGw(*client, pubrelMsg, "PUBREL");
    verifySent_PubcompMsg(state, dataProc, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubrecMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    dataFromGw(*client, pubrelMsg, "PUBREL");
    verifySent_PubcompMsg(state, dataProc, expectedMsgId);
    // Although marked as duplicate, it is considered to be a new message
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);
    verifyNoOtherEvent(state);

    clearState(state);
    ++expectedMsgId;
    state.m_nextElapsedTicks = 1000;
    publishMsg = dataProc.preparePublishMsg(TopicId, expectedMsgId, Data, TopicIdType, Qos, Retain, true);
    dataFromGw(*client, publishMsg, "PUBLISH");
    verifySent_PubrecMsg(state, dataProc, expectedMsgId);
    TS_ASSERT(state.m_reportedMsgs.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    pubrelMsg = dataProc.preparePubrelMsg(expectedMsgId);
    dataFromGw(*client, pubrelMsg, "PUBREL");
    verifySent_PubcompMsg(state, dataProc, expectedMsgId);
    verifyCb_ReportedMessage(state, Topic, TopicId, Data, transformQos(Qos), Retain);
    verifyNoOtherEvent(state);
}

void ClientBasic::test27()
{
    DataProcessor dataProc;
    typedef TestBasicState Test27State;

    Test27State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const MqttsnTopicId TopicId = 0x1234;
    static const auto Qos = MqttsnQoS_AtLeastOnceDelivery;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->subscribe(TopicId, Qos);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_SubsribeMsg(state, dataProc, TopicId, Qos, false);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto subackMsg = dataProc.prepareSubackMsg(transformQos(Qos), TopicId, msgId + 1, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, subackMsg, "SUBACK");
    TS_ASSERT(state.m_reportedSubscribes.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    auto msgId2 = verifySent_SubsribeMsg(state, dataProc, TopicId, Qos, true);
    TS_ASSERT_EQUALS(msgId, msgId2);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    subackMsg = dataProc.prepareSubackMsg(transformQos(Qos), TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Successful, Qos);
    verifyNoOtherEvent(state);
}

void ClientBasic::test28()
{
    DataProcessor dataProc;
    typedef TestBasicState Test28State;
    Test28State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string Topic("/this/is/topic");
    static const auto Qos1 = MqttsnQoS_ExactlyOnceDelivery;
    static const auto Qos2 = MqttsnQoS_AtLeastOnceDelivery;

    auto result = client->subscribe(Topic, Qos1);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotConnected);

    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos1);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_SubsribeMsg(state, dataProc, Topic, Qos1, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos2);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Busy);
    verifyNoOtherEvent(state);

    static const MqttsnTopicId TopicId = 0x1111;
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto subackMsg = dataProc.prepareSubackMsg(transformQos(Qos2), TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Congestion);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Congestion, Qos2);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos1);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_SubsribeMsg(state, dataProc, Topic, Qos1, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    subackMsg = dataProc.prepareSubackMsg(transformQos(Qos2), TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Successful, Qos2);
    verifyNoOtherEvent(state);

    static const DataSeq Data = {
        0x0, 0x1, 0x2, 0xa, 0xb, 0xc
    };
    static const bool Retain = true;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->publish(Topic, &Data[0], Data.size(), Qos2, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdTypeVal::Normal, Qos2, Retain, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test29()
{
    DataProcessor dataProc;
    typedef TestBasicState Test29State;
    Test29State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("/this/is/topic");
    static const auto Qos = MqttsnQoS_ExactlyOnceDelivery;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->subscribe(Topic, Qos);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_SubsribeMsg(state, dataProc, Topic, Qos, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 5000;
    client->cancel();
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Aborted, Qos);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_SubsribeMsg(state, dataProc, Topic, Qos, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_SubsribeMsg(state, dataProc, Topic, Qos, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_SubsribeMsg(state, dataProc, Topic, Qos, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_NoResponse, Qos);
    verifyNoOtherEvent(state);

    static const MqttsnTopicId TopicId = 0x1233;
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(TopicId, Qos);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_SubsribeMsg(state, dataProc, TopicId, Qos, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto subackMsg = dataProc.prepareSubackMsg(transformQos(Qos), 0, msgId, cc_mqttsn::field::ReturnCodeVal::InvalidTopicId);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_InvalidId, Qos);
    verifyNoOtherEvent(state);
}

void ClientBasic::test30()
{
    DataProcessor dataProc;
    typedef TestBasicState Test30State;
    Test30State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("/this/is/topic");
    static const MqttsnTopicId TopicId = 0x1111;
    static const auto Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const std::uint16_t RegMsgId = 1;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto registerMsg = dataProc.prepareRegisterMsg(TopicId, RegMsgId, Topic);
    dataFromGw(*client, registerMsg, "REGISTER");
    verifySent_RegackMsg(state, dataProc, TopicId, RegMsgId);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->subscribe(Topic, Qos);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    // Even if topic is pre-registered, use subscribe by topic name
    auto msgId = verifySent_SubsribeMsg(state, dataProc, Topic, Qos, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto subackMsg = dataProc.prepareSubackMsg(transformQos(Qos), TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Successful, Qos);
    verifyNoOtherEvent(state);

    static const DataSeq Data = { 0x0, 0x1, 0x2 };
    static const bool Retain = true;
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdTypeVal::Normal, Qos, Retain, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::InvalidTopicId);
    dataFromGw(*client, pubackMsg, "PUBACK");
    TS_ASSERT(state.m_reportedPublishes.empty());
    verifySent_RegisterMsg(state, dataProc, Topic);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->cancel();
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Aborted);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_SubsribeMsg(state, dataProc, Topic, Qos, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    subackMsg = dataProc.prepareSubackMsg(transformQos(Qos), TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Successful, Qos);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->publish(Topic, &Data[0], Data.size(), Qos, Retain);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdTypeVal::Normal, Qos, Retain, false);
    pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test31()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string Topic("/this/is/topic");

    auto result = client->unsubscribe(Topic);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotConnected);

    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->unsubscribe(Topic);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_UnsubsribeMsg(state, dataProc, Topic);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->unsubscribe(Topic);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Busy);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto unsubackMsg = dataProc.prepareUnsubackMsg(msgId);
    dataFromGw(*client, unsubackMsg, "UNSUBACK");
    verifyCb_ReportedUnsubsribe(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test32()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const MqttsnTopicId TopicId = 1111;

    auto result = client->unsubscribe(TopicId);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotConnected);

    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->unsubscribe(TopicId);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_UnsubsribeMsg(state, dataProc, TopicId);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->unsubscribe(TopicId);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Busy);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->cancel();
    verifyCb_ReportedUnsubsribe(state, MqttsnAsyncOpStatus_Aborted);
    verifyNoOtherEvent(state);

    result = client->unsubscribe(TopicId);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_UnsubsribeMsg(state, dataProc, TopicId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_UnsubsribeMsg(state, dataProc, TopicId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_UnsubsribeMsg(state, dataProc, TopicId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifyCb_ReportedUnsubsribe(state, MqttsnAsyncOpStatus_NoResponse);
    verifyNoOtherEvent(state);

    result = client->unsubscribe(TopicId);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_UnsubsribeMsg(state, dataProc, TopicId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    auto unsubackMsg = dataProc.prepareUnsubackMsg(msgId);
    dataFromGw(*client, unsubackMsg, "UNSUBACK");
    verifyCb_ReportedUnsubsribe(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test33()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string Topic("/bla/bla/bla");
    static const MqttsnTopicId TopicId = 1111;
    static const std::uint16_t RegMsgId = 5555;
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    doTopicRegister(*client, dataProc, state, Topic, TopicId, RegMsgId);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->unsubscribe(Topic);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    // Unsubscribe by full topic even if pre-registered
    auto msgId = verifySent_UnsubsribeMsg(state, dataProc, Topic);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    auto unsubackMsg = dataProc.prepareUnsubackMsg(msgId);
    dataFromGw(*client, unsubackMsg, "UNSUBACK");
    verifyCb_ReportedUnsubsribe(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test34()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string WillTopic("will/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->willTopicUpdate(WillTopic, Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_WilltopicupdMsg(state, dataProc, WillTopic, Qos, Retain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto msgRespMsg = dataProc.prepareWillmsgrespMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, msgRespMsg, "WILLMSGRESP");
    TS_ASSERT(state.m_nextOutput.empty());
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto topicRespMsg = dataProc.prepareWilltopicrespMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, topicRespMsg, "WILLTOPICRESP");
    verifyCb_ReportedWillTopicUpdate(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);

    static const DataSeq Data = {0x0, 0x2, 0x3};
    result = client->willMsgUpdate(&Data[0], Data.size());
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_WillmsgupdMsg(state, dataProc, Data);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    dataFromGw(*client, topicRespMsg, "WILLTOPICRESP");
    TS_ASSERT(state.m_nextOutput.empty());
    TS_ASSERT(state.m_reportedWillMsgUpdates.empty());
    TS_ASSERT(state.m_reportedWillMsgUpdates.empty());
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout - 1000);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    dataFromGw(*client, msgRespMsg, "WILLMSGRESP");
    verifyCb_ReportedWillMsgUpdate(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test35()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string WillTopic("will/topic");
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->willTopicUpdate(WillTopic, Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_WilltopicupdMsg(state, dataProc, WillTopic, Qos, Retain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    TS_ASSERT(state.m_reportedWillUpdates.empty());
    verifySent_WilltopicupdMsg(state, dataProc, WillTopic, Qos, Retain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    TS_ASSERT(state.m_reportedWillUpdates.empty());
    verifySent_WilltopicupdMsg(state, dataProc, WillTopic, Qos, Retain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifyCb_ReportedWillTopicUpdate(state, MqttsnAsyncOpStatus_NoResponse);
    verifyNoOtherEvent(state);
}

void ClientBasic::test36()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string WillTopic("will/topic");
    static const DataSeq Data;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->willTopicUpdate(WillTopic.c_str(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_WilltopicupdMsg(state, dataProc, WillTopic, Qos, Retain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto topicRespMsg = dataProc.prepareWilltopicrespMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, topicRespMsg, "WILLTOPICRESP");
    verifyCb_ReportedWillTopicUpdate(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);

    result = client->willMsgUpdate(nullptr, 0);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_WillmsgupdMsg(state, dataProc, Data);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    TS_ASSERT(state.m_reportedWillUpdates.empty());
    verifySent_WillmsgupdMsg(state, dataProc, Data);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    TS_ASSERT(state.m_reportedWillUpdates.empty());
    verifySent_WillmsgupdMsg(state, dataProc, Data);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifyCb_ReportedWillMsgUpdate(state, MqttsnAsyncOpStatus_NoResponse);
    verifyNoOtherEvent(state);
}

void ClientBasic::test37()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string WillTopic("will/topic");
    static const DataSeq Data;
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->willTopicUpdate(WillTopic.c_str(), Qos, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_WilltopicupdMsg(state, dataProc, WillTopic, Qos, Retain);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->cancel();
    verifyCb_ReportedWillTopicUpdate(state, MqttsnAsyncOpStatus_Aborted);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->willMsgUpdate(nullptr, 0);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_WillmsgupdMsg(state, dataProc, Data);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->cancel();
    verifyCb_ReportedWillMsgUpdate(state, MqttsnAsyncOpStatus_Aborted);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto msgRespMsg = dataProc.prepareWillmsgrespMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, msgRespMsg, "WILLMSGRESP");
    TS_ASSERT(state.m_nextOutput.empty());
    verifyNoOtherEvent(state);
}

void ClientBasic::test38()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::uint16_t Duration = 10000;
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->sleep(Duration);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_DisconnectMsg(state, dataProc, Duration);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    client->cancel();
    verifyCb_ReportedSleep(state, MqttsnAsyncOpStatus_Aborted);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->sleep(Duration);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_DisconnectMsg(state, dataProc, Duration);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_DisconnectMsg(state, dataProc, Duration);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_DisconnectMsg(state, dataProc, Duration);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifyCb_ReportedSleep(state, MqttsnAsyncOpStatus_NoResponse);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->sleep(Duration);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_DisconnectMsg(state, dataProc, Duration);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto disconnectMsg = dataProc.prepareDisconnectMsg(Duration);
    dataFromGw(*client, disconnectMsg, "DISCONNECT");
    verifyCb_ReportedSleep(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, 0);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    static const std::string ClientId = "test_client";
    result = client->connect(ClientId.c_str(), DefaultKeepAlive, true, nullptr);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_AlreadyConnected);
    verifyNoOtherEvent(state);
}

void ClientBasic::test39()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    auto& clientId = doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    auto result = client->checkMessages();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotSleeping);

    static const std::uint16_t Duration = 10000;
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->sleep(Duration);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_DisconnectMsg(state, dataProc, Duration);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto disconnectMsg = dataProc.prepareDisconnectMsg(Duration);
    dataFromGw(*client, disconnectMsg, "DISCONNECT");
    verifyCb_ReportedSleep(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, 0);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 2000;
    result = client->checkMessages();
    verifySent_PingreqMsg(state, dataProc, clientId);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    static const MqttsnTopicId TopicId = 0x1111;
    static const std::uint16_t MsgId = 0x2222;
    static const DataSeq Data = {0x0, 0x1, 0x2};
    static const MqttsnQoS Qos = MqttsnQoS_AtMostOnceDelivery;
    static const bool Retain = false;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto publishMsg =
        dataProc.preparePublishMsg(
            TopicId,
            MsgId,
            Data,
            TopicIdTypeVal::PredefinedTopicId,
            transformQos(Qos),
            false,
            false);

    dataFromGw(*client, publishMsg, "PUBLISH");
    dataFromGw(*client, publishMsg, "PUBLISH");
    dataFromGw(*client, publishMsg, "PUBLISH");

    verifyCb_ReportedMessage(state, std::string(), TopicId, Data, Qos, Retain);
    verifyCb_ReportedMessage(state, std::string(), TopicId, Data, Qos, Retain);
    verifyCb_ReportedMessage(state, std::string(), TopicId, Data, Qos, Retain);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pingrespMsg = dataProc.preparePingrespMsg();
    dataFromGw(*client, pingrespMsg, "PINGRESP");
    verifyCb_ReportedMessageChecks(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, 0);
    verifyNoOtherEvent(state);

    result = client->reconnect();
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_ConnectMsg(state, dataProc, DefaultClientId, DefaultKeepAlive, false, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    client->tick();
    verifySent_ConnectMsg(state, dataProc, DefaultClientId, DefaultKeepAlive, false, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto connackMsg = dataProc.prepareConnackMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");
    verifyCb_ReportedReconnect(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test40()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state, true);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    static const std::string WillTopic("will/topic/upd");
    static const DataBuf WillData = {1, 1, 1, 1};
    static const MqttsnQoS Qos = MqttsnQoS_AtLeastOnceDelivery;
    static const bool Retain = true;

    auto info = MqttsnWillInfo();
    info.topic = WillTopic.c_str();
    info.msg = &WillData[0];
    info.msgLen = static_cast<decltype(info.msgLen)>(WillData.size());
    info.qos = Qos;
    info.retain = Retain;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->willUpdate(&info);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_ConnectMsg(state, dataProc, DefaultClientId, DefaultKeepAlive, false, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto topicReqMsg = dataProc.prepareWilltopicreqMsg();
    dataFromGw(*client, topicReqMsg, "WILLTOPICREQ");
    verifySent_WilltopicMsg(state, dataProc, WillTopic, Qos, Retain);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto msgReqMsg = dataProc.prepareWillmsgreqMsg();
    dataFromGw(*client, msgReqMsg, "WILLMSGREQ");
    verifySent_WillmsgMsg(state, dataProc, WillData);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto connackMsg = dataProc.prepareConnackMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");
    verifyCb_ReportedWillUpdate(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test41()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);
    doConnect(*client, dataProc, state, true);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    auto info = MqttsnWillInfo();

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto result = client->willUpdate(&info);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_ConnectMsg(state, dataProc, DefaultClientId, DefaultKeepAlive, false, true);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto topicReqMsg = dataProc.prepareWilltopicreqMsg();
    dataFromGw(*client, topicReqMsg, "WILLTOPICREQ");
    verifySent_WilltopicMsg(state, dataProc, std::string(), MqttsnQoS_AtMostOnceDelivery, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto connackMsg = dataProc.prepareConnackMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");
    verifyCb_ReportedWillUpdate(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test42()
{
    // Connect with will
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const unsigned short KeepAlive = 60;

    TS_TRACE("Connecting...");

    state.m_nextElapsedTicks = 0;
    auto result =
        client->connect(nullptr, KeepAlive, true, nullptr);

    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    verifySent_ConnectMsg(state, dataProc, std::string(), KeepAlive, true, false);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultRetryTimeout);
    verifyNoOtherEvent(state);

    clearState(state);
    static const unsigned NextTicks = 1000;
    state.m_nextElapsedTicks = NextTicks;
    auto connackMsg = dataProc.prepareConnackMsg(cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, connackMsg, "CONNACK");

    // check connected
    verifyCb_ReportedConnect(state, MqttsnAsyncOpStatus_Successful);
    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, (KeepAlive * 1000) - NextTicks);
    verifyNoOtherEvent(state);
}

void ClientBasic::test43()
{
    // Connect with will
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    client->setSearchgwEnabled(false);
    startClient(*client);
    TS_ASSERT(state.m_nextOutput.empty());
    verifyNoOtherEvent(state);
}

void ClientBasic::test44()
{
    DataProcessor dataProc;
    typedef TestBasicState Test44State;
    Test44State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string Topic("tt"); // Short topic
    static const auto Qos1 = MqttsnQoS_ExactlyOnceDelivery;
    static const auto Qos2 = MqttsnQoS_AtLeastOnceDelivery;

    auto result = client->subscribe(Topic, Qos1);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotConnected);

    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos1);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_SubsribeMsg(state, dataProc, Topic, Qos1, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos2);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Busy);
    verifyNoOtherEvent(state);

    static const auto TopicId =
        static_cast<MqttsnTopicId>(
            (static_cast<MqttsnTopicId>(Topic[0]) << 8U) | static_cast<std::uint8_t>(Topic[1]));
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto subackMsg = dataProc.prepareSubackMsg(transformQos(Qos2), TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Congestion);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Congestion, Qos2);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos1);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_SubsribeMsg(state, dataProc, Topic, Qos1, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    subackMsg = dataProc.prepareSubackMsg(transformQos(Qos2), TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Successful, Qos2);
    verifyNoOtherEvent(state);

    static const DataSeq Data = {
        0x0, 0x1, 0x2, 0xa, 0xb, 0xc
    };
    static const bool Retain = true;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->publish(Topic, &Data[0], Data.size(), Qos2, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdTypeVal::ShortTopicName, Qos2, Retain, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test45()
{
    DataProcessor dataProc;
    typedef TestBasicState Test45State;
    Test45State state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string Topic("#"); // Wildcard topic
    static const auto Qos1 = MqttsnQoS_ExactlyOnceDelivery;
    static const auto Qos2 = MqttsnQoS_AtLeastOnceDelivery;

    auto result = client->subscribe(Topic, Qos1);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotConnected);

    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos1);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_SubsribeMsg(state, dataProc, Topic, Qos1, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos2);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Busy);
    verifyNoOtherEvent(state);

    static const MqttsnTopicId TopicId = 0x1111;
    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto subackMsg = dataProc.prepareSubackMsg(transformQos(Qos2), TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Congestion);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Congestion, Qos2);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->subscribe(Topic, Qos1);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_SubsribeMsg(state, dataProc, Topic, Qos1, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    subackMsg = dataProc.prepareSubackMsg(transformQos(Qos2), TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, subackMsg, "SUBACK");
    verifyCb_ReportedSubsribe(state, MqttsnAsyncOpStatus_Successful, Qos2);
    verifyNoOtherEvent(state);

    static const DataSeq Data = {
        0x0, 0x1, 0x2, 0xa, 0xb, 0xc
    };
    static const bool Retain = true;

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->publish(Topic, &Data[0], Data.size(), Qos2, Retain);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    msgId = verifySent_PublishMsg(state, dataProc, TopicId, Data, TopicIdTypeVal::Normal, Qos2, Retain, false);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto pubackMsg = dataProc.preparePubackMsg(TopicId, msgId, cc_mqttsn::field::ReturnCodeVal::Accepted);
    dataFromGw(*client, pubackMsg, "PUBACK");
    verifyCb_ReportedPublish(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}

void ClientBasic::test46()
{
    DataProcessor dataProc;
    TestBasicState state;

    auto client = allocClient(&state, &dataProc);
    startClient(*client);

    doGwInfo(*client, dataProc, state);
    clearState(state);

    static const std::string Topic("tt"); // Short topic

    auto result = client->unsubscribe(Topic);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_NotConnected);

    clearState(state);
    doConnect(*client, dataProc, state);

    TS_ASSERT_EQUALS(state.m_nextRequestedTicks, DefaultKeepAlive * 1000);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->unsubscribe(Topic);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Success);
    auto msgId = verifySent_UnsubsribeMsg(state, dataProc, Topic);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    result = client->unsubscribe(Topic);
    TS_ASSERT_EQUALS(result, MqttsnErrorCode_Busy);
    verifyNoOtherEvent(state);

    clearState(state);
    state.m_nextElapsedTicks = 1000;
    auto unsubackMsg = dataProc.prepareUnsubackMsg(msgId);
    dataFromGw(*client, unsubackMsg, "UNSUBACK");
    verifyCb_ReportedUnsubsribe(state, MqttsnAsyncOpStatus_Successful);
    verifyNoOtherEvent(state);
}
