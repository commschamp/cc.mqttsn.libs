#include "UnitTestDefaultBase.h"
#include "UnitTestProtocolDefs.h"

#include "comms/units.h"

#include <cxxtest/TestSuite.h>

class UnitTestUnsubscribe : public CxxTest::TestSuite, public UnitTestDefaultBase
{
public:
    void test1();
    void test2();
    void test3();
    void test4();

private:
    virtual void setUp() override
    {
        unitTestSetUp();
    }

    virtual void tearDown() override
    {
        unitTestTearDown();
    }    

    using TopicIdType = UnitTestUnsubscribeMsg::Field_flags::Field_topicIdType::ValueType;
};

void UnitTestUnsubscribe::test1()
{
    // Testing basic topic unsubscribe

    auto clientPtr = unitTestAllocClient(true);
    auto* client = clientPtr.get();

    const std::string ClientId("bla");
    unitTestDoConnectBasic(client, ClientId);

    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 1000);

    const std::string Topic("#");

    unitTestDoSubscribeTopic(client, Topic);

    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 1000);

    auto unsubscribe = apiUnsubscribePrepare(client);
    TS_ASSERT_DIFFERS(unsubscribe, nullptr);

    CC_MqttsnUnsubscribeConfig config;
    apiUnsubscribeInitConfig(&config);
    config.m_topic = Topic.c_str();

    auto ec = apiUnsubscribeConfig(unsubscribe, &config);
    TS_ASSERT_EQUALS(ec, CC_MqttsnErrorCode_Success);

    ec = unitTestUnsubscribeSend(unsubscribe);
    TS_ASSERT_EQUALS(ec, CC_MqttsnErrorCode_Success);

    auto unsubMsgId = 0U;
    {
        TS_ASSERT(unitTestHasOutputData());
        auto sentMsg = unitTestPopOutputMessage();
        auto* unsubscribeMsg = dynamic_cast<UnitTestUnsubscribeMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(unsubscribeMsg, nullptr);
        TS_ASSERT_EQUALS(unsubscribeMsg->field_flags().field_topicIdType().value(), TopicIdType::Normal);
        TS_ASSERT(unsubscribeMsg->field_topicId().isMissing());
        TS_ASSERT(unsubscribeMsg->field_topicName().doesExist());
        TS_ASSERT_EQUALS(unsubscribeMsg->field_topicName().field().value(), Topic);
        TS_ASSERT(!unitTestHasOutputData());
        unsubMsgId = unsubscribeMsg->field_msgId().value();
        TS_ASSERT_DIFFERS(unsubMsgId, 0U);
    }   

    TS_ASSERT(!unitTestHasUnsubscribeCompleteReport());
    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 100);

    {
        UnitTestUnsubackMsg unsubackMsg;
        unsubackMsg.field_msgId().setValue(unsubMsgId);
        unitTestClientInputMessage(client, unsubackMsg);
    }

    TS_ASSERT(unitTestHasUnsubscribeCompleteReport());
    auto unsubscribeReport = unitTestUnsubscribeCompleteReport();
    TS_ASSERT_EQUALS(unsubscribeReport->m_handle, unsubscribe);
    TS_ASSERT_EQUALS(unsubscribeReport->m_status, CC_MqttsnAsyncOpStatus_Complete);

    TS_ASSERT(unitTestHasTickReq());
}

void UnitTestUnsubscribe::test2()
{
    // Testing basic topic id unsubscribe

    auto clientPtr = unitTestAllocClient(true);
    auto* client = clientPtr.get();

    const std::string ClientId("bla");
    unitTestDoConnectBasic(client, ClientId);

    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 1000);

    const CC_MqttsnTopicId TopicId = 123;

    unitTestDoSubscribeTopicId(client, TopicId);

    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 1000);

    auto unsubscribe = apiUnsubscribePrepare(client);
    TS_ASSERT_DIFFERS(unsubscribe, nullptr);

    CC_MqttsnUnsubscribeConfig config;
    apiUnsubscribeInitConfig(&config);
    config.m_topicId = TopicId;

    auto ec = apiUnsubscribeConfig(unsubscribe, &config);
    TS_ASSERT_EQUALS(ec, CC_MqttsnErrorCode_Success);

    ec = unitTestUnsubscribeSend(unsubscribe);
    TS_ASSERT_EQUALS(ec, CC_MqttsnErrorCode_Success);

    auto unsubMsgId = 0U;
    {
        TS_ASSERT(unitTestHasOutputData());
        auto sentMsg = unitTestPopOutputMessage();
        auto* unsubscribeMsg = dynamic_cast<UnitTestUnsubscribeMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(unsubscribeMsg, nullptr);
        TS_ASSERT_EQUALS(unsubscribeMsg->field_flags().field_topicIdType().value(), TopicIdType::PredefinedTopicId);
        TS_ASSERT(unsubscribeMsg->field_topicId().doesExist());
        TS_ASSERT(unsubscribeMsg->field_topicName().isMissing());
        TS_ASSERT_EQUALS(unsubscribeMsg->field_topicId().field().value(), TopicId);
        TS_ASSERT(!unitTestHasOutputData());
        unsubMsgId = unsubscribeMsg->field_msgId().value();
        TS_ASSERT_DIFFERS(unsubMsgId, 0U);
    }   

    TS_ASSERT(!unitTestHasUnsubscribeCompleteReport());
    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 100);

    {
        UnitTestUnsubackMsg unsubackMsg;
        unsubackMsg.field_msgId().setValue(unsubMsgId);
        unitTestClientInputMessage(client, unsubackMsg);
    }

    TS_ASSERT(unitTestHasUnsubscribeCompleteReport());
    auto unsubscribeReport = unitTestUnsubscribeCompleteReport();
    TS_ASSERT_EQUALS(unsubscribeReport->m_handle, unsubscribe);
    TS_ASSERT_EQUALS(unsubscribeReport->m_status, CC_MqttsnAsyncOpStatus_Complete);

    TS_ASSERT(unitTestHasTickReq());
}

void UnitTestUnsubscribe::test3()
{
    // Testing short topic name unsubscribe

    auto clientPtr = unitTestAllocClient(true);
    auto* client = clientPtr.get();

    const std::string ClientId("bla");
    unitTestDoConnectBasic(client, ClientId);

    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 1000);

    const std::string Topic("ab");

    unitTestDoSubscribeTopic(client, Topic);

    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 1000);

    auto unsubscribe = apiUnsubscribePrepare(client);
    TS_ASSERT_DIFFERS(unsubscribe, nullptr);

    CC_MqttsnUnsubscribeConfig config;
    apiUnsubscribeInitConfig(&config);
    config.m_topic = Topic.c_str();

    auto ec = apiUnsubscribeConfig(unsubscribe, &config);
    TS_ASSERT_EQUALS(ec, CC_MqttsnErrorCode_Success);

    ec = unitTestUnsubscribeSend(unsubscribe);
    TS_ASSERT_EQUALS(ec, CC_MqttsnErrorCode_Success);

    auto unsubMsgId = 0U;
    {
        TS_ASSERT(unitTestHasOutputData());
        auto sentMsg = unitTestPopOutputMessage();
        auto* unsubscribeMsg = dynamic_cast<UnitTestUnsubscribeMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(unsubscribeMsg, nullptr);
        TS_ASSERT_EQUALS(unsubscribeMsg->field_flags().field_topicIdType().value(), TopicIdType::ShortTopicName);
        TS_ASSERT(unsubscribeMsg->field_topicId().doesExist());
        TS_ASSERT(unsubscribeMsg->field_topicName().isMissing());
        auto topicId = unsubscribeMsg->field_topicId().field().value();
        TS_ASSERT_EQUALS((topicId >> 8U) & 0xff, static_cast<unsigned>(Topic[0]));
        TS_ASSERT_EQUALS(topicId & 0xff, static_cast<unsigned>(Topic[1]));
        TS_ASSERT(!unitTestHasOutputData());
        unsubMsgId = unsubscribeMsg->field_msgId().value();
        TS_ASSERT_DIFFERS(unsubMsgId, 0U);
    }   

    TS_ASSERT(!unitTestHasUnsubscribeCompleteReport());
    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 100);

    {
        UnitTestUnsubackMsg unsubackMsg;
        unsubackMsg.field_msgId().setValue(unsubMsgId);
        unitTestClientInputMessage(client, unsubackMsg);
    }

    TS_ASSERT(unitTestHasUnsubscribeCompleteReport());
    auto unsubscribeReport = unitTestUnsubscribeCompleteReport();
    TS_ASSERT_EQUALS(unsubscribeReport->m_handle, unsubscribe);
    TS_ASSERT_EQUALS(unsubscribeReport->m_status, CC_MqttsnAsyncOpStatus_Complete);

    TS_ASSERT(unitTestHasTickReq());
}

void UnitTestUnsubscribe::test4()
{
    // Testing unsubscribe that hasn't been subscribed before

    auto clientPtr = unitTestAllocClient(true);
    auto* client = clientPtr.get();

    const std::string ClientId("bla");
    unitTestDoConnectBasic(client, ClientId);

    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 1000);

    const std::string Topic("ab");

    auto unsubscribe = apiUnsubscribePrepare(client);
    TS_ASSERT_DIFFERS(unsubscribe, nullptr);

    CC_MqttsnUnsubscribeConfig config;
    apiUnsubscribeInitConfig(&config);
    config.m_topic = Topic.c_str();

    auto ec = apiUnsubscribeConfig(unsubscribe, &config);
    TS_ASSERT_EQUALS(ec, CC_MqttsnErrorCode_BadParam);

    ec = apiSetVerifyIncomingMsgSubscribed(client, false);
    ec = apiUnsubscribeConfig(unsubscribe, &config);
    TS_ASSERT_EQUALS(ec, CC_MqttsnErrorCode_Success);

    ec = unitTestUnsubscribeSend(unsubscribe);
    TS_ASSERT_EQUALS(ec, CC_MqttsnErrorCode_Success);

    auto unsubMsgId = 0U;
    {
        TS_ASSERT(unitTestHasOutputData());
        auto sentMsg = unitTestPopOutputMessage();
        auto* unsubscribeMsg = dynamic_cast<UnitTestUnsubscribeMsg*>(sentMsg.get());
        TS_ASSERT_DIFFERS(unsubscribeMsg, nullptr);
        TS_ASSERT_EQUALS(unsubscribeMsg->field_flags().field_topicIdType().value(), TopicIdType::ShortTopicName);
        TS_ASSERT(unsubscribeMsg->field_topicId().doesExist());
        TS_ASSERT(unsubscribeMsg->field_topicName().isMissing());
        auto topicId = unsubscribeMsg->field_topicId().field().value();
        TS_ASSERT_EQUALS((topicId >> 8U) & 0xff, static_cast<unsigned>(Topic[0]));
        TS_ASSERT_EQUALS(topicId & 0xff, static_cast<unsigned>(Topic[1]));
        TS_ASSERT(!unitTestHasOutputData());
        unsubMsgId = unsubscribeMsg->field_msgId().value();
        TS_ASSERT_DIFFERS(unsubMsgId, 0U);
    }   

    TS_ASSERT(!unitTestHasUnsubscribeCompleteReport());
    TS_ASSERT(unitTestHasTickReq());
    unitTestTick(client, 100);

    {
        UnitTestUnsubackMsg unsubackMsg;
        unsubackMsg.field_msgId().setValue(unsubMsgId);
        unitTestClientInputMessage(client, unsubackMsg);
    }

    TS_ASSERT(unitTestHasUnsubscribeCompleteReport());
    auto unsubscribeReport = unitTestUnsubscribeCompleteReport();
    TS_ASSERT_EQUALS(unsubscribeReport->m_handle, unsubscribe);
    TS_ASSERT_EQUALS(unsubscribeReport->m_status, CC_MqttsnAsyncOpStatus_Complete);

    TS_ASSERT(unitTestHasTickReq());
}
