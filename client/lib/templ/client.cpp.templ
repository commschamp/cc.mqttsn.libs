//
// Copyright 2016 - 2024 (C). Alex Robenko. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#include "##NAME##client.h"
#include "ClientAllocator.h"
#include "ExtConfig.h"

#include "comms/Assert.h"
//#include "comms/util/ScopeGuard.h"

#include <limits>

struct CC_MqttsnClient {};

namespace
{

cc_mqttsn_client::ClientAllocator& getClientAllocator()
{
    static cc_mqttsn_client::ClientAllocator Allocator;
    return Allocator;
}

inline cc_mqttsn_client::ClientImpl* clientFromHandle(CC_MqttsnClientHandle handle)
{
    return reinterpret_cast<cc_mqttsn_client::ClientImpl*>(handle);
}

inline CC_MqttsnClientHandle handleFromClient(cc_mqttsn_client::ClientImpl* client)
{
    return reinterpret_cast<CC_MqttsnClientHandle>(client);
}

}  // namespace

CC_MqttsnClientHandle cc_mqttsn_##NAME##client_new()
{
    auto client = getClientAllocator().alloc();
    return handleFromClient(client.release());   
}

void cc_mqttsn_##NAME##client_free(CC_MqttsnClientHandle handle)
{
    getClientAllocator().free(clientFromHandle(handle));
}

void cc_mqttsn_##NAME##client_tick(CC_MqttsnClientHandle client, unsigned ms)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->tick(ms);
}

void cc_mqttsn_##NAME##client_process_data(CC_MqttsnClientHandle client, const unsigned char* buf, unsigned bufLen)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->processData(buf, bufLen);    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_set_retry_period(CC_MqttsnClientHandle client, unsigned value)
{
    COMMS_ASSERT(client != nullptr);
    static const unsigned MaxValue = std::numeric_limits<decltype(cc_mqttsn_client::ConfigState::m_responseTimeoutMs)>::max() / 1000U;
    if (MaxValue < value) {
        clientFromHandle(client)->errorLog("The retry period value is too high");
        return CC_MqttsnErrorCode_BadParam;
    }

    clientFromHandle(client)->configState().m_responseTimeoutMs = value * 1000U;
    return CC_MqttsnErrorCode_Success;
}

unsigned cc_mqttsn_##NAME##client_get_retry_period(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    return clientFromHandle(client)->configState().m_responseTimeoutMs;    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_set_retry_count(CC_MqttsnClientHandle client, unsigned value)
{
    COMMS_ASSERT(client != nullptr);
    if (value < 1U) {
        clientFromHandle(client)->errorLog("The retry count setting must be greater than zero.");
        return CC_MqttsnErrorCode_BadParam;
    }

    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->configState().m_retryCount = value;    
    return CC_MqttsnErrorCode_Success;
}

unsigned cc_mqttsn_##NAME##client_get_retry_count(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    return clientFromHandle(client)->configState().m_retryCount;      
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_set_broadcast_radius(CC_MqttsnClientHandle client, unsigned value)
{
    COMMS_ASSERT(client != nullptr);
    if (cc_mqttsn_client::ConfigState::MaxBroadcastRadius < value) {
        clientFromHandle(client)->errorLog("The broadcast radius is too high");
        return CC_MqttsnErrorCode_BadParam;
    }

    clientFromHandle(client)->configState().m_broadcastRadius = value;
    return CC_MqttsnErrorCode_Success;
}

unsigned cc_mqttsn_##NAME##client_get_broadcast_radius(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    return clientFromHandle(client)->configState().m_broadcastRadius;
}

// --------------------- Callbacks ---------------------

void cc_mqttsn_##NAME##client_set_next_tick_program_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnNextTickProgramCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setNextTickProgramCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_cancel_next_tick_wait_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnCancelNextTickWaitCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setCancelNextTickWaitCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_send_output_data_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnSendOutputDataCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setSendOutputDataCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_gw_status_report_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnGwStatusReportCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setGatewayStatusReportCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_gw_disconnect_report_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnGwDisconnectedReportCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setGatewayDisconnectedReportCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_message_report_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnMessageReportCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setMessageReceivedCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_gwinfo_delay_request_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnGwinfoDelayRequestCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setGwinfoDelayReqCb(cb, data);
}
