//
// Copyright 2016 - 2024 (C). Alex Robenko. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#include "##NAME##client.h"
#include "ClientAllocator.h"
#include "ExtConfig.h"

#include "comms/Assert.h"
#include "comms/util/ScopeGuard.h"

#include <limits>

struct CC_MqttsnClient {};
struct CC_MqttsnSearch {};
struct CC_MqttsnConnect {};

namespace
{

cc_mqttsn_client::ClientAllocator& getClientAllocator()
{
    static cc_mqttsn_client::ClientAllocator Allocator;
    return Allocator;
}

inline cc_mqttsn_client::ClientImpl* clientFromHandle(CC_MqttsnClientHandle handle)
{
    return reinterpret_cast<cc_mqttsn_client::ClientImpl*>(handle);
}

inline CC_MqttsnClientHandle handleFromClient(cc_mqttsn_client::ClientImpl* client)
{
    return reinterpret_cast<CC_MqttsnClientHandle>(client);
}

#if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
inline cc_mqttsn_client::op::SearchOp* searchOpFromHandle(CC_MqttsnSearchHandle handle)
{
    return reinterpret_cast<cc_mqttsn_client::op::SearchOp*>(handle);
}
#endif // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY

inline CC_MqttsnSearchHandle handleFromSearchOp(cc_mqttsn_client::op::SearchOp* op)
{
    return reinterpret_cast<CC_MqttsnSearchHandle>(op);
}

inline cc_mqttsn_client::op::ConnectOp* connectOpFromHandle(CC_MqttsnConnectHandle handle)
{
    return reinterpret_cast<cc_mqttsn_client::op::ConnectOp*>(handle);
}

inline CC_MqttsnConnectHandle handleFromConnectOp(cc_mqttsn_client::op::ConnectOp* op)
{
    return reinterpret_cast<CC_MqttsnConnectHandle>(op);
}

}  // namespace

CC_MqttsnClientHandle cc_mqttsn_##NAME##client_alloc()
{
    auto client = getClientAllocator().alloc();
    return handleFromClient(client.release());   
}

void cc_mqttsn_##NAME##client_free(CC_MqttsnClientHandle handle)
{
    getClientAllocator().free(clientFromHandle(handle));
}

void cc_mqttsn_##NAME##client_tick(CC_MqttsnClientHandle client, unsigned ms)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->tick(ms);
}

void cc_mqttsn_##NAME##client_process_data(CC_MqttsnClientHandle client, const unsigned char* buf, unsigned bufLen)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->processData(buf, bufLen);    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_set_default_retry_period(CC_MqttsnClientHandle client, unsigned value)
{
    COMMS_ASSERT(client != nullptr);
    static const unsigned MaxValue = std::numeric_limits<decltype(cc_mqttsn_client::ConfigState::m_retryPeriod)>::max() / 1000U;
    if (MaxValue < value) {
        clientFromHandle(client)->errorLog("The retry period value is too high");
        return CC_MqttsnErrorCode_BadParam;
    }

    clientFromHandle(client)->configState().m_retryPeriod = value * 1000U;
    return CC_MqttsnErrorCode_Success;
}

unsigned cc_mqttsn_##NAME##client_get_default_retry_period(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    return clientFromHandle(client)->configState().m_retryPeriod;    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_set_default_retry_count(CC_MqttsnClientHandle client, unsigned value)
{
    COMMS_ASSERT(client != nullptr);
    if (value < 1U) {
        clientFromHandle(client)->errorLog("The retry count setting must be greater than zero.");
        return CC_MqttsnErrorCode_BadParam;
    }

    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->configState().m_retryCount = value;    
    return CC_MqttsnErrorCode_Success;
}

unsigned cc_mqttsn_##NAME##client_get_default_retry_count(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    return clientFromHandle(client)->configState().m_retryCount;      
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_set_default_broadcast_radius(CC_MqttsnClientHandle client, unsigned value)
{
    COMMS_ASSERT(client != nullptr);
    if (cc_mqttsn_client::ConfigState::MaxBroadcastRadius < value) {
        clientFromHandle(client)->errorLog("The broadcast radius is too high");
        return CC_MqttsnErrorCode_BadParam;
    }

    clientFromHandle(client)->configState().m_broadcastRadius = value;
    return CC_MqttsnErrorCode_Success;
}

unsigned cc_mqttsn_##NAME##client_get_default_broadcast_radius(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    return clientFromHandle(client)->configState().m_broadcastRadius;
}

unsigned cc_mqttsn_##NAME##client_get_available_gateways_count(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    return static_cast<unsigned>(clientFromHandle(client)->clientState().m_gwInfos.size());
}

void cc_mqttsn_##NAME##client_init_gateway_info(CC_MqttsnGatewayInfo* info)
{
    COMMS_ASSERT(info != nullptr);
    *info = CC_MqttsnGatewayInfo();
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_get_available_gateway_info(CC_MqttsnClientHandle client, unsigned idx, CC_MqttsnGatewayInfo* info)
{
    COMMS_ASSERT(client != nullptr);
    auto clientPtr = clientFromHandle(client);
    if (info == nullptr) {
        clientPtr->errorLog("The provided gateway info pointer is invalid");
        return CC_MqttsnErrorCode_BadParam;
    }

    auto& gwInfos = clientPtr->clientState().m_gwInfos;
    if (gwInfos.size() <= idx) {
        clientPtr->errorLog("The gateway info index is too high");
        return CC_MqttsnErrorCode_BadParam;
    }

    auto& storedInfo = gwInfos[idx];
    *info = CC_MqttsnGatewayInfo();
    info->m_gwId = storedInfo.m_gwId;
    if (!storedInfo.m_addr.empty()) {
        info->m_addr = storedInfo.m_addr.data();
        info->m_addrLen = static_cast<decltype(info->m_addrLen)>(storedInfo.m_addr.size());
    }

    return CC_MqttsnErrorCode_Success;
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_set_available_gateway_info(CC_MqttsnClientHandle client, const CC_MqttsnGatewayInfo* info)
{
    COMMS_ASSERT(client != nullptr);
    auto* clientImpl = clientFromHandle(client);
    if (info == nullptr) {
        clientImpl->errorLog("The gateway info is not provided");
        return CC_MqttsnErrorCode_BadParam;
    }

    auto& gwInfos = clientImpl->clientState().m_gwInfos;
    auto iter = 
        std::find_if(
            gwInfos.begin(), gwInfos.end(),
            [info](auto& storedInfo)
            {
                return storedInfo.m_gwId == info->m_gwId;
            });

    auto updateFunc = 
        [clientImpl, info](cc_mqttsn_client::ClientState::GwInfo& storedInfo)
        {
            if (storedInfo.m_addr.max_size() < info->m_addrLen) {
                clientImpl->errorLog("The address cannot be stored");
                return CC_MqttsnErrorCode_OutOfMemory;
            }

            storedInfo.m_gwId = info->m_gwId;
            storedInfo.m_addr.assign(info->m_addr, info->m_addr + info->m_addrLen);
            return CC_MqttsnErrorCode_Success;
        };

    if (iter != gwInfos.end()) {
        return updateFunc(*iter);
    }

    if (gwInfos.max_size() <= gwInfos.size()) {
        clientImpl->errorLog("Cannot store any more gateways");
        return CC_MqttsnErrorCode_OutOfMemory;
    }

    gwInfos.resize(gwInfos.size() + 1U);
    auto result = updateFunc(gwInfos.back());
    if (result != CC_MqttsnErrorCode_Success) {
        gwInfos.pop_back();
    }

    return result;
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_discard_available_gateway_info(CC_MqttsnClientHandle client, unsigned char gwId)
{
    COMMS_ASSERT(client != nullptr);
    auto* clientImpl = clientFromHandle(client);
    auto& gwInfos = clientImpl->clientState().m_gwInfos;
    auto iter = 
        std::find_if(
            gwInfos.begin(), gwInfos.end(),
            [gwId](auto& storedInfo)
            {
                return storedInfo.m_gwId = gwId;
            });

    if (iter == gwInfos.end()) {
        clientImpl->errorLog("Uknown gateway ID");
        return CC_MqttsnErrorCode_BadParam;
    }            

    gwInfos.erase(iter);
    return CC_MqttsnErrorCode_Success;
}

void cc_mqttsn_##NAME##client_discard_all_gateway_infos(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->clientState().m_gwInfos.clear();    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_set_default_gw_adv_duration(CC_MqttsnClientHandle client, unsigned ms)
{
    COMMS_ASSERT(client != nullptr);
    auto* clientImpl = clientFromHandle(client);
    if (ms == 0U) {
        clientImpl->errorLog("The default gatway advertise duration must be greater than 0");
        return CC_MqttsnErrorCode_BadParam;
    }

    clientImpl->configState().m_gwAdvTimeoutMs = ms;    
    return CC_MqttsnErrorCode_Success;    
}

unsigned cc_mqttsn_##NAME##client_get_default_gw_adv_duration(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    return clientFromHandle(client)->configState().m_gwAdvTimeoutMs;
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_set_allowed_adv_losses(CC_MqttsnClientHandle client, unsigned count)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->configState().m_allowedAdvLosses = count;
    return CC_MqttsnErrorCode_Success;
}

unsigned cc_mqttsn_##NAME##client_get_allowed_adv_losses(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    return clientFromHandle(client)->configState().m_allowedAdvLosses;
}

CC_MqttsnSearchHandle cc_mqttsn_##NAME##client_search_prepare(
    [[maybe_unused]] CC_MqttsnClientHandle client, 
    [[maybe_unused]] CC_MqttsnErrorCode* ec)
{
#if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY       
    COMMS_ASSERT(client != nullptr);
    return handleFromSearchOp(clientFromHandle(client)->searchPrepare(ec));
#else // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY   
    clientFromHandle(client)->errorLog("Gateway discovery support for excluded from compilation");
    if (ec != nullptr) {
        *ec = CC_MqttsnErrorCode_NotSupported;
    }
    return nullptr;
#endif // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY   
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_search_set_retry_period(
    [[maybe_unused]] CC_MqttsnSearchHandle handle, 
    [[maybe_unused]] unsigned ms)
{
#if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY    

    COMMS_ASSERT(handle != nullptr);
    if (ms == 0U) {
        searchOpFromHandle(handle)->client().errorLog("The retry period must be greater than 0");
        return CC_MqttsnErrorCode_BadParam;
    }
    
    COMMS_ASSERT(handle != nullptr);
    searchOpFromHandle(handle)->setRetryPeriod(ms);     
    return CC_MqttsnErrorCode_Success;

#else // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY

    return CC_MqttsnErrorCode_NotSupported;

#endif // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
}

unsigned cc_mqttsn_##NAME##client_search_get_retry_period([[maybe_unused]] CC_MqttsnSearchHandle handle)
{
    
#if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY        
    COMMS_ASSERT(handle != nullptr);
    return searchOpFromHandle(handle)->getRetryPeriod();    
#else // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY    
    COMMS_ASSERT(false); // Should not be called
    return 0U;
#endif // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_search_set_retry_count(
    [[maybe_unused]] CC_MqttsnSearchHandle handle, 
    [[maybe_unused]] unsigned count)
{
#if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY        
    COMMS_ASSERT(handle != nullptr);
    searchOpFromHandle(handle)->setRetryCount(count);     
    return CC_MqttsnErrorCode_Success;    

#else // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY    

    return CC_MqttsnErrorCode_NotSupported;

#endif // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY    
}

unsigned cc_mqttsn_##NAME##client_search_get_retry_count([[maybe_unused]] CC_MqttsnSearchHandle handle)
{
#if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY    
    COMMS_ASSERT(handle != nullptr);
    return searchOpFromHandle(handle)->getRetryCount();       
#else // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
    COMMS_ASSERT(false); // Should not be called
    return 0U;
#endif // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_search_set_broadcast_radius(
    [[maybe_unused]] CC_MqttsnSearchHandle handle, 
    [[maybe_unused]] unsigned broadcastRadius)
{
#if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY

    COMMS_ASSERT(handle != nullptr);
    if (broadcastRadius == 0U) {
        searchOpFromHandle(handle)->client().errorLog("The broadcast radius must be greater than 0");
        return CC_MqttsnErrorCode_BadParam;
    }    
    
    searchOpFromHandle(handle)->setBroadcastRadius(broadcastRadius);     
    return CC_MqttsnErrorCode_Success;  

#else // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY

    return CC_MqttsnErrorCode_NotSupported;

#endif // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
}

unsigned cc_mqttsn_##NAME##client_search_get_broadcast_radius([[maybe_unused]] CC_MqttsnSearchHandle handle)
{
#if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
    COMMS_ASSERT(handle != nullptr);
    return searchOpFromHandle(handle)->getBroadcastRadius();       
#else // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
    COMMS_ASSERT(false); // Should not be called
    return 0U;
#endif // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_search_send(
    [[maybe_unused]] CC_MqttsnSearchHandle handle, 
    [[maybe_unused]] CC_MqttsnSearchCompleteCb cb, 
    [[maybe_unused]] void* cbData)
{
#if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
    COMMS_ASSERT(handle != nullptr);
    return searchOpFromHandle(handle)->send(cb, cbData);
#else // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
    return CC_MqttsnErrorCode_NotSupported;
#endif // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_search(
    CC_MqttsnClientHandle handle,
    CC_MqttsnSearchCompleteCb cb, 
    void* cbData)
{
    auto ec = CC_MqttsnErrorCode_Success;
    auto search = cc_mqttsn_##NAME##client_search_prepare(handle, &ec);
    if (search == nullptr) {
        return ec;
    }

    return cc_mqttsn_##NAME##client_search_send(search, cb, cbData);    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_search_cancel([[maybe_unused]] CC_MqttsnSearchHandle handle)
{
#if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY    
    COMMS_ASSERT(handle != nullptr);
    return searchOpFromHandle(handle)->cancel();    
#else // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
    return CC_MqttsnErrorCode_NotSupported;
#endif // #if CC_MQTTSN_CLIENT_HAS_GATEWAY_DISCOVERY
}

CC_MqttsnConnectHandle cc_mqttsn_##NAME##client_connect_prepare(CC_MqttsnClientHandle client, CC_MqttsnErrorCode* ec)
{
    COMMS_ASSERT(client != nullptr);
    return handleFromConnectOp(clientFromHandle(client)->connectPrepare(ec));
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_connect_set_retry_period(CC_MqttsnConnectHandle handle, unsigned ms)
{
    COMMS_ASSERT(handle != nullptr);
    if (ms == 0U) {
        connectOpFromHandle(handle)->client().errorLog("The retry period must be greater than 0");
        return CC_MqttsnErrorCode_BadParam;
    }
    
    COMMS_ASSERT(handle != nullptr);
    connectOpFromHandle(handle)->setRetryPeriod(ms);     
    return CC_MqttsnErrorCode_Success;
}

unsigned cc_mqttsn_##NAME##client_connect_get_retry_period(CC_MqttsnConnectHandle handle)
{
    COMMS_ASSERT(handle != nullptr);
    return connectOpFromHandle(handle)->getRetryPeriod();    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_connect_set_retry_count(CC_MqttsnConnectHandle handle, unsigned count)
{
    COMMS_ASSERT(handle != nullptr);
    connectOpFromHandle(handle)->setRetryCount(count);     
    return CC_MqttsnErrorCode_Success;  
}

unsigned cc_mqttsn_##NAME##client_connect_get_retry_count(CC_MqttsnConnectHandle handle)
{
    COMMS_ASSERT(handle != nullptr);
    return connectOpFromHandle(handle)->getRetryCount();     
}

void cc_mqttsn_##NAME##client_connect_init_config(CC_MqttsnConnectConfig* config)
{
    COMMS_ASSERT(config != nullptr);
    *config = CC_MqttsnConnectConfig();
    config->m_duration = cc_mqttsn_client::ClientState::DefaultKeepAlive;
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_connect_config(CC_MqttsnConnectHandle handle, const CC_MqttsnConnectConfig* config)
{
    COMMS_ASSERT(handle != nullptr);
    return connectOpFromHandle(handle)->config(config);
}

void cc_mqttsn_##NAME##client_connect_init_config_will(CC_MqttsnWillConfig* config)
{
    COMMS_ASSERT(config != nullptr);
    *config = CC_MqttsnWillConfig();    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_connect_config_will(CC_MqttsnConnectHandle handle, const CC_MqttsnWillConfig* config)
{
    COMMS_ASSERT(handle != nullptr);
    return connectOpFromHandle(handle)->willConfig(config);    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_connect_send(CC_MqttsnConnectHandle handle, CC_MqttsnConnectCompleteCb cb, void* cbData)
{
    COMMS_ASSERT(handle != nullptr);
    return connectOpFromHandle(handle)->send(cb, cbData);
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_connect_cancel(CC_MqttsnConnectHandle handle)
{
    COMMS_ASSERT(handle != nullptr);
    return connectOpFromHandle(handle)->cancel();    
}

CC_MqttsnErrorCode cc_mqttsn_##NAME##client_connect(
    CC_MqttsnClientHandle client,
    const CC_MqttsnConnectConfig* config,
    const CC_MqttsnWillConfig* willConfig,
    CC_MqttsnConnectCompleteCb cb, 
    void* cbData)
{
    auto ec = CC_MqttsnErrorCode_Success;
    auto connect = cc_mqttsn_##NAME##client_connect_prepare(client, &ec);
    if (connect == nullptr) {
        return ec;
    }

    auto cancelOnExitGuard = 
        comms::util::makeScopeGuard(
            [connect]()
            {
                [[maybe_unused]] auto ecTmp = cc_mqttsn_##NAME##client_connect_cancel(connect);
            });    

    if (config != nullptr) {
        ec = cc_mqttsn_##NAME##client_connect_config(connect, config);
        if (ec != CC_MqttsnErrorCode_Success) {
            return ec;
        }
    }

    if (willConfig != nullptr) {
        ec = cc_mqttsn_##NAME##client_connect_config_will(connect, willConfig);
        if (ec != CC_MqttsnErrorCode_Success) {
            return ec;
        }        
    }

    cancelOnExitGuard.release();
    return cc_mqttsn_##NAME##client_connect_send(connect, cb, cbData);    
}

bool cc_mqttsn_##NAME##client_is_connected(CC_MqttsnClientHandle client)
{
    COMMS_ASSERT(client != nullptr);
    return clientFromHandle(client)->sessionState().m_connected;
}

// --------------------- Callbacks ---------------------

void cc_mqttsn_##NAME##client_set_next_tick_program_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnNextTickProgramCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setNextTickProgramCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_cancel_next_tick_wait_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnCancelNextTickWaitCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setCancelNextTickWaitCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_send_output_data_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnSendOutputDataCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setSendOutputDataCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_gw_status_report_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnGwStatusReportCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setGatewayStatusReportCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_gw_disconnect_report_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnGwDisconnectedReportCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setGatewayDisconnectedReportCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_message_report_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnMessageReportCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setMessageReceivedCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_error_log_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnErrorLogCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setErrorLogCallback(cb, data);
}

void cc_mqttsn_##NAME##client_set_gwinfo_delay_request_callback(
    CC_MqttsnClientHandle client,
    CC_MqttsnGwinfoDelayRequestCb cb,
    void* data)
{
    COMMS_ASSERT(client != nullptr);
    clientFromHandle(client)->setGwinfoDelayReqCb(cb, data);
}
