//
// Copyright 2016 (C). Alex Robenko. All rights reserved.
//

// This file is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <list>
#include <vector>
#include <memory>

#include "comms/comms.h"
#include "mqttsn/gateway/Session.h"

CC_DISABLE_WARNINGS()
#include "cxxtest/TestSuite.h"
CC_ENABLE_WARNINGS()

#include "TestMsgHandler.h"

class SessionTest : public CxxTest::TestSuite
{
public:
    void test1();
    void test2();
    void test3();
    void test4();
    void test5();
    void test6();
    void test7();
    void test8();
    void test9();
    void test10();
    void test11();
    void test12();
    void test13();
    void test14();
    void test15();
    void test16();
    void test17();
    void test18();
    void test19();
    void test20();
    void test21();
    void test22();
    void test23();
    void test24();
    void test25();

private:
    typedef std::unique_ptr<mqttsn::gateway::Session> SessionPtr;
    typedef std::vector<std::uint8_t> DataBuf;

    static const std::uint8_t DefaultGwId = 5;
    static const std::uint16_t DefaultKeepAlivePeriod = 60;
    static const unsigned DefaultRetryPeriod = 15;
    static const unsigned DefaultRetryCount = 3;
    static const std::string DefaultClientId;
    static const std::uint16_t DefaultMinTopicId = 1000;
    static const std::uint16_t DefaultMaxTopicId = 2000;

    struct State
    {
        std::list<DataBuf> m_sentToClient;
        std::list<DataBuf> m_sentToBroker;
        std::list<unsigned> m_tickReq;
        std::list<unsigned> m_elapsed;
        std::list<bool> m_termRequests;
        std::list<bool> m_brokerReconnectRequests;
    };

    struct WillInfo
    {
        std::string m_topic;
        DataBuf m_msg;
        mqtt::field::QosType m_qos = mqtt::field::QosType::AtMostOnceDelivery;
        bool m_retain = false;
    };

    static SessionPtr allocSession(
        State& state,
        TestMsgHandler& handler,
        const std::uint8_t gwId = DefaultGwId,
        const std::string* username = nullptr,
        const DataBuf* password = nullptr)
    {
        SessionPtr session(new mqttsn::gateway::Session);
        if (username != nullptr) {
            std::size_t passLen = 0;
            const std::uint8_t* passPtr = nullptr;
            if (password != nullptr) {
                passPtr = &((*password)[0]);
                passLen = password->size();
            }

            session->setAuthInfo(*username, passPtr, passLen);
        }

        session->setNextTickProgramReqCb(
            [&state](unsigned val) {
                state.m_tickReq.push_back(val);
            });

        session->setCancelTickWaitReqCb(
            [&state]() -> unsigned
            {
                if (state.m_elapsed.empty()) {
                    assert(!"Elapsed timeout is not specified");
                    return 0U;
                }

                auto val = state.m_elapsed.front();
                TS_TRACE("[Elapsed]: " + std::to_string(val));
                state.m_elapsed.pop_front();
                return val;
            });
        session->setSendDataClientReqCb(
            [&state](const std::uint8_t* buf, std::size_t bufSize)
            {
                state.m_sentToClient.emplace_back(buf, buf + bufSize);
            });

        session->setSendDataBrokerReqCb(
            [&state](const std::uint8_t* buf, std::size_t bufSize)
            {
                state.m_sentToBroker.emplace_back(buf, buf + bufSize);
            });

        session->setTerminationReqCb(
            [&state]()
            {
                state.m_termRequests.push_back(true);
            });

        session->setBrokerReconnectReqCb(
            [&state]()
            {
                state.m_brokerReconnectRequests.push_back(true);
            });

        handler.setGwinfoMsgHandler(
            [](const GwinfoMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- GWINFO");
            });

        handler.setConnackMsgHandler(
            [](const ConnackMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- CONNACK");
            });

        handler.setWilltopicreqMsgHandler(
            [](const WilltopicreqMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- WILLTOPICREQ");
            });

        handler.setWillmsgreqMsgHandler(
            [](const WillmsgreqMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- WILLMSGREQ");
            });

        handler.setDisconnectSnMsgHandler(
            [](const DisconnectMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- DISCONNECT");
            });

        handler.setRegisterMsgHandler(
            [](const RegisterMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- REGISTER");
            });

        handler.setRegackMsgHandler(
            [](const RegackMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- REGACK");
            });

        handler.setPublishSnMsgHandler(
            [](const PublishMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- PUBLISH");
            });

        handler.setPubackSnMsgHandler(
            [](const PubackMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- PUBACK");
            });

        handler.setPubrecSnMsgHandler(
            [](const PubrecMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- PUBREC");
            });

        handler.setPubrelSnMsgHandler(
            [](const PubrelMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- PUBREL");
            });

        handler.setPubcompSnMsgHandler(
            [](const PubcompMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- PUBCOMP");
            });

        handler.setPingreqSnMsgHandler(
            [](const PingreqMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- PINGREQ");
            });

        handler.setPingrespSnMsgHandler(
            [](const PingrespMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- PINGRESP");
            });

        handler.setSubackSnMsgHandler(
            [](const SubackMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- SUBACK");
            });

        handler.setUnsubackSnMsgHandler(
            [](const UnsubackMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- UNSUBACK");
            });

        handler.setWilltopicrespMsgHandler(
            [](const WilltopicrespMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- WILLTOPICRESP");
            });

        handler.setWillmsgrespMsgHandler(
            [](const WillmsgrespMsg_SN&)
            {
                TS_TRACE("(CLIENT) <-- WILLMSGRESP");
            });

        handler.setConnectMsgHandler(
            [](const ConnectMsg&)
            {
                TS_TRACE("(BROKER) <-- CONNECT");
            });

        handler.setDisconnectMsgHandler(
            [](const DisconnectMsg&)
            {
                TS_TRACE("(BROKER) <-- DISCONNECT");
            });

        handler.setPingreqMsgHandler(
            [](const PingreqMsg&)
            {
                TS_TRACE("(BROKER) <-- PINGREQ");
            });

        handler.setPingrespMsgHandler(
            [](const PingrespMsg&)
            {
                TS_TRACE("(BROKER) <-- PINGRESP");
            });

        handler.setPublishMsgHandler(
            [](const PublishMsg&)
            {
                TS_TRACE("(BROKER) <-- PUBLISH");
            });

        handler.setPubackMsgHandler(
            [](const PubackMsg&)
            {
                TS_TRACE("(BROKER) <-- PUBACK");
            });

        handler.setPubrecMsgHandler(
            [](const PubrecMsg&)
            {
                TS_TRACE("(BROKER) <-- PUBREC");
            });

        handler.setPubrelMsgHandler(
            [](const PubrelMsg&)
            {
                TS_TRACE("(BROKER) <-- PUBREL");
            });

        handler.setPubcompMsgHandler(
            [](const PubcompMsg&)
            {
                TS_TRACE("(BROKER) <-- PUBCOMP");
            });

        handler.setSubscribeMsgHandler(
            [](const SubscribeMsg&)
            {
                TS_TRACE("(BROKER) <-- SUBSCRIBE");
            });

        handler.setUnsubscribeMsgHandler(
            [](const UnsubscribeMsg&)
            {
                TS_TRACE("(BROKER) <-- UNSUBSCRIBE");
            });


        session->setRetryPeriod(DefaultRetryPeriod);
        session->setRetryCount(DefaultRetryCount);
        session->setGatewayId(gwId);
        session->setTopicIdAllocationRange(DefaultMinTopicId, DefaultMaxTopicId);
        bool result = session->start();
        session->setBrokerConnected(true);
        TS_ASSERT(result);
        TS_ASSERT(session->isRunning());
        TS_ASSERT(state.m_sentToClient.empty());
        TS_ASSERT(state.m_sentToBroker.empty());
        TS_ASSERT(state.m_tickReq.empty());
        TS_ASSERT(state.m_elapsed.empty());
        return std::move(session);
    }

    static void dataFromClient(
        mqttsn::gateway::Session& session,
        const DataBuf& buf,
        const std::string& msgStr)
    {
        auto consumed = session.dataFromClient(&buf[0], buf.size());
        TS_ASSERT_EQUALS(consumed, buf.size());
        TS_TRACE("(CLIENT) --> " + msgStr);
    }

    static void dataFromBroker(
        mqttsn::gateway::Session& session,
        const DataBuf& buf,
        const std::string& msgStr)
    {
        auto consumed = session.dataFromBroker(&buf[0], buf.size());
        TS_ASSERT_EQUALS(consumed, buf.size());
        TS_TRACE("(BROKER) --> " + msgStr);

//        std::cout << std::hex;
//        std::copy(buf.begin(), buf.end(), std::ostream_iterator<unsigned>(std::cout, " "));
//        std::cout << std::endl;
    }

    static void checkTickValue(State& state, unsigned value)
    {
        if (state.m_tickReq.empty()) {
            TS_FAIL("Tick wan't requested");
            return;
        }

        TS_ASSERT_EQUALS(state.m_tickReq.front(), value);
    }

    static void verifySent_GwinfoMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint8_t gwId)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setGwinfoMsgHandler(
                [&](const GwinfoMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- GWINFO");

                    typedef GwinfoMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& gwIdField = std::get<MsgType::FieldIdx_gwId>(fields);

                    TS_ASSERT_EQUALS(gwIdField.value(), gwId);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setGwinfoMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_ConnackMsg(
        State& state,
        TestMsgHandler& handler,
        mqttsn::protocol::field::ReturnCodeVal rc)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setConnackMsgHandler(
                [&](const ConnackMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- CONNACK");

                    typedef ConnackMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& retCodeField = std::get<MsgType::FieldIdx_returnCode>(fields);

                    TS_ASSERT_EQUALS(retCodeField.value(), rc);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setConnackMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_WilltopicreqMsg(State& state, TestMsgHandler& handler)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setWilltopicreqMsgHandler(
                [&](const WilltopicreqMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- WILLTOPICREQ");
                    static_cast<void>(msg);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setWilltopicreqMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_WillmsgreqMsg(State& state, TestMsgHandler& handler)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setWillmsgreqMsgHandler(
                [&](const WillmsgreqMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- WILLMSGREQ");
                    static_cast<void>(msg);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setWillmsgreqMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_DisconnectMsg(State& state, TestMsgHandler& handler)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setDisconnectSnMsgHandler(
                [&](const DisconnectMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- DISCONNECT");

                    typedef DisconnectMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& duration = std::get<MsgType::FieldIdx_duration>(fields);
                    TS_ASSERT_EQUALS(duration.getMode(), comms::field::OptionalMode::Missing);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setDisconnectSnMsgHandler(std::move(oldCb));
    }

    static std::uint16_t verifySentToClient_RegackMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t msgId,
        mqttsn::protocol::field::ReturnCodeVal rc)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return 0U;
        }

        bool sent = false;
        std::uint16_t topicId = 0U;
        auto oldCb =
            handler.setRegackMsgHandler(
                [&](const RegackMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- REGACK");

                    typedef RegackMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& topicIdField = std::get<MsgType::FieldIdx_topicId>(fields);
                    auto& msgIdField = std::get<MsgType::FieldIdx_msgId>(fields);
                    auto& retCodeField = std::get<MsgType::FieldIdx_returnCode>(fields);

                    TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                    TS_ASSERT_EQUALS(retCodeField.value(), rc);
                    topicId = topicIdField.value();
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setRegackMsgHandler(std::move(oldCb));
        TS_TRACE("[Topic ID]: " + std::to_string(topicId));
        return topicId;
    }

    static std::tuple<std::uint16_t, std::uint16_t> verifySentToClient_RegisterMsg(
        State& state,
        TestMsgHandler& handler,
        const std::string& topic)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return std::make_tuple(0U, 0U);
        }

        bool sent = false;
        std::uint16_t topicId = 0U;
        std::uint16_t msgId = 0U;
        auto oldCb =
            handler.setRegisterMsgHandler(
                [&](const RegisterMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- REGISTER");

                    typedef RegisterMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& topicIdField = std::get<MsgType::FieldIdx_topicId>(fields);
                    auto& msgIdField = std::get<MsgType::FieldIdx_msgId>(fields);
                    auto& topicNameField = std::get<MsgType::FieldIdx_topicName>(fields);

                    TS_ASSERT_EQUALS(topicNameField.value(), topic);
                    topicId = topicIdField.value();
                    msgId = msgIdField.value();
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setRegisterMsgHandler(std::move(oldCb));
        TS_TRACE("[Topic ID]: " + std::to_string(topicId));
        TS_TRACE("[Msg ID]: " + std::to_string(msgId));
        return std::make_tuple(topicId, msgId);
    }

    static std::uint16_t verifySentToClient_PublishMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t topicId,
        const DataBuf& msgData,
        mqttsn::protocol::field::TopicIdTypeVal topicType,
        mqttsn::protocol::field::QosType qos,
        bool retain,
        bool duplicate)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return 0U;
        }

        bool sent = false;
        std::uint16_t msgId = 0U;
        auto oldCb =
            handler.setPublishSnMsgHandler(
                [&](const PublishMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- PUBLISH");

                    typedef PublishMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& flagsField = std::get<MsgType::FieldIdx_flags>(fields);
                    auto& flagsMembers = flagsField.value();
                    auto& topicIdTypeField = std::get<mqttsn::protocol::field::FlagsMemberIdx_topicId>(flagsMembers);
                    auto& midFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_midFlags>(flagsMembers);
                    auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
                    auto& dupFlagsField = std::get<mqttsn::protocol::field::FlagsMemberIdx_dupFlags>(flagsMembers);
                    auto& topicIdField = std::get<MsgType::FieldIdx_topicId>(fields);
                    auto& msgIdField = std::get<MsgType::FieldIdx_msgId>(fields);
                    auto& dataField = std::get<MsgType::FieldIdx_data>(fields);

                    TS_ASSERT_EQUALS(topicIdTypeField.value(), topicType);
                    TS_ASSERT_EQUALS(midFlagsField.getBitValue(mqttsn::protocol::field::MidFlagsBits_retain), retain);
                    TS_ASSERT_EQUALS(qosField.value(), qos);
                    TS_ASSERT_EQUALS(dupFlagsField.getBitValue(mqttsn::protocol::field::DupFlagsBits_dup), duplicate);
                    TS_ASSERT_EQUALS(topicIdField.value(), topicId);
                    TS_ASSERT_EQUALS(dataField.value(), msgData);
                    msgId = msgIdField.value();
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setPublishSnMsgHandler(std::move(oldCb));
        TS_TRACE("[Msg ID]: " + std::to_string(msgId));
        return msgId;
    }

    static void verifySentToClient_PubackMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t topicId,
        std::uint16_t msgId,
        mqttsn::protocol::field::ReturnCodeVal rc)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPubackSnMsgHandler(
                [&](const PubackMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- PUBACK");

                    typedef PubackMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& topicIdField = std::get<MsgType::FieldIdx_topicId>(fields);
                    auto& msgIdField = std::get<MsgType::FieldIdx_msgId>(fields);
                    auto& retCodeField = std::get<MsgType::FieldIdx_returnCode>(fields);

                    TS_ASSERT_EQUALS(topicIdField.value(), topicId);
                    TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                    TS_ASSERT_EQUALS(retCodeField.value(), rc);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setPubackSnMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_PubrecMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t msgId)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPubrecSnMsgHandler(
                [&](const PubrecMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- PUBREC");

                    typedef PubrecMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& msgIdField = std::get<MsgType::FieldIdx_msgId>(fields);

                    TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setPubrecSnMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_PubrelMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t msgId)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPubrelSnMsgHandler(
                [&](const PubrelMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- PUBREL");

                    typedef PubrelMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& msgIdField = std::get<MsgType::FieldIdx_msgId>(fields);

                    TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setPubrelSnMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_PubcompMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t msgId)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPubcompSnMsgHandler(
                [&](const PubcompMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- PUBCOMP");

                    typedef PubcompMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& msgIdField = std::get<MsgType::FieldIdx_msgId>(fields);

                    TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setPubcompSnMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_PingreqMsg(
        State& state,
        TestMsgHandler& handler)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPingreqSnMsgHandler(
                [&](const PingreqMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- PINGREQ");
                    auto& fields = msg.fields();
                    auto& clientIdField = std::get<PingreqMsg_SN::FieldIdx_clientId>(fields);
                    TS_ASSERT(clientIdField.value().empty());
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setPingreqSnMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_PingrespMsg(
        State& state,
        TestMsgHandler& handler)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPingrespSnMsgHandler(
                [&](const PingrespMsg_SN& msg)
                {
                    static_cast<void>(msg);
                    sent = true;
                    TS_TRACE("(CLIENT) <-- PINGRESP");
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setPingrespSnMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_SubackMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t topicId,
        std::uint16_t msgId,
        mqttsn::protocol::field::QosType qos,
        mqttsn::protocol::field::ReturnCodeVal rc)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setSubackSnMsgHandler(
                [&](const SubackMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- SUBACK");
                    typedef SubackMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& flagsField = std::get<MsgType::FieldIdx_flags>(fields);
                    auto& flagsMembers = flagsField.value();
                    auto& qosField = std::get<mqttsn::protocol::field::FlagsMemberIdx_qos>(flagsMembers);
                    auto& topicIdField = std::get<MsgType::FieldIdx_topicId>(fields);
                    auto& msgIdField = std::get<MsgType::FieldIdx_msgId>(fields);
                    auto& retCodeField = std::get<MsgType::FieldIdx_returnCode>(fields);

                    TS_ASSERT_EQUALS(qosField.value(), qos);
                    TS_ASSERT_EQUALS(topicIdField.value(), topicId);
                    TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                    TS_ASSERT_EQUALS(retCodeField.value(), rc);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setSubackSnMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_UnsubackMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t msgId)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setUnsubackSnMsgHandler(
                [&](const UnsubackMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- UNSUBACK");
                    typedef UnsubackMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& msgIdField = std::get<MsgType::FieldIdx_msgId>(fields);

                    TS_ASSERT_EQUALS(msgIdField.value(), msgId);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setUnsubackSnMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_WilltopicrespMsg(
        State& state,
        TestMsgHandler& handler,
        mqttsn::protocol::field::ReturnCodeVal rc)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setWilltopicrespMsgHandler(
                [&](const WilltopicrespMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- WILLTOPICRESP");
                    typedef WilltopicrespMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& retCodeField = std::get<MsgType::FieldIdx_returnCode>(fields);

                    TS_ASSERT_EQUALS(retCodeField.value(), rc);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setWilltopicrespMsgHandler(std::move(oldCb));
    }

    static void verifySentToClient_WillmsgrespMsg(
        State& state,
        TestMsgHandler& handler,
        mqttsn::protocol::field::ReturnCodeVal rc)
    {
        if (state.m_sentToClient.empty()) {
            TS_FAIL("No data was sent to client");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setWillmsgrespMsgHandler(
                [&](const WillmsgrespMsg_SN& msg)
                {
                    sent = true;
                    TS_TRACE("(CLIENT) <-- WILLMSGRESP");
                    typedef WillmsgrespMsg_SN MsgType;
                    auto& fields = msg.fields();
                    auto& retCodeField = std::get<MsgType::FieldIdx_returnCode>(fields);

                    TS_ASSERT_EQUALS(retCodeField.value(), rc);
                });

        handler.processDataForClient(state.m_sentToClient.front());
        TS_ASSERT(sent);

        state.m_sentToClient.pop_front();
        handler.setWillmsgrespMsgHandler(std::move(oldCb));
    }


    static void verifySentToBroker_ConnectMsg(
        State& state,
        TestMsgHandler& handler,
        const std::string& clientId,
        std::uint16_t keepAlive,
        bool cleanSession,
        const WillInfo* willInfo = nullptr,
        const std::string& username = std::string(),
        const DataBuf& password = DataBuf())
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setConnectMsgHandler(
                [&](const ConnectMsg& msg)
                {
                    sent = true;
                    TS_TRACE("(BROKER) <-- CONNECT");

                    typedef ConnectMsg MsgType;
                    auto& fields = msg.fields();
                    auto& flagsField = std::get<MsgType::FieldIdx_Flags>(fields);
                    auto& flagsMembers = flagsField.value();
                    auto& lowFlagsField = std::get<mqtt::message::ConnectFlagsMemberIdx_FlagsLow>(flagsMembers);
                    auto& willQosField = std::get<mqtt::message::ConnectFlagsMemberIdx_WillQos>(flagsMembers);
                    auto& highFlagsField = std::get<mqtt::message::ConnectFlagsMemberIdx_FlagsHigh>(flagsMembers);
                    auto& keepAliveField = std::get<MsgType::FieldIdx_KeepAlive>(fields);
                    auto& clientIdField = std::get<MsgType::FieldIdx_ClientId>(fields);
                    auto& willTopicField = std::get<MsgType::FieldIdx_WillTopic>(fields);
                    auto& willMsgField = std::get<MsgType::FieldIdx_WillMessage>(fields);
                    auto& usernameField = std::get<MsgType::FieldIdx_UserName>(fields);
                    auto& passwordField = std::get<MsgType::FieldIdx_Password>(fields);

                    TS_ASSERT_EQUALS(keepAliveField.value(), keepAlive);
                    TS_ASSERT_EQUALS(clientIdField.value(), clientId);
                    TS_ASSERT_EQUALS(lowFlagsField.getBitValue(mqtt::message::ConnectFlagsLowBitIdx_CleanSession), cleanSession);

                    bool hasWill = ((willInfo != nullptr) && (!willInfo->m_topic.empty()));
                    TS_ASSERT_EQUALS(lowFlagsField.getBitValue(mqtt::message::ConnectFlagsLowBitIdx_WillFlag), hasWill);

                    if (hasWill) {
                        TS_ASSERT_EQUALS(willQosField.value(), willInfo->m_qos);
                        TS_ASSERT_EQUALS(highFlagsField.getBitValue(mqtt::message::ConnectFlagsHighBitIdx_WillRetain), willInfo->m_retain);
                        TS_ASSERT_EQUALS(willTopicField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(willMsgField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(willTopicField.field().value(), willInfo->m_topic);
                        TS_ASSERT_EQUALS(willMsgField.field().value(), willInfo->m_msg);
                    }
                    else {
                        TS_ASSERT_EQUALS(willTopicField.getMode(), comms::field::OptionalMode::Missing);
                        TS_ASSERT_EQUALS(willMsgField.getMode(), comms::field::OptionalMode::Missing);
                    }

                    TS_ASSERT_EQUALS(highFlagsField.getBitValue(mqtt::message::ConnectFlagsHighBitIdx_UserNameFlag), !username.empty());
                    TS_ASSERT_EQUALS(highFlagsField.getBitValue(mqtt::message::ConnectFlagsHighBitIdx_PasswordFlag), !password.empty());

                    if (!username.empty()) {
                        TS_ASSERT_EQUALS(usernameField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(usernameField.field().value(), username);
                    }
                    else {
                        TS_ASSERT_EQUALS(usernameField.getMode(), comms::field::OptionalMode::Missing);
                    }

                    if (!password.empty()) {
                        TS_ASSERT_EQUALS(passwordField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(passwordField.field().value(), password);
                    }
                    else {
                        TS_ASSERT_EQUALS(passwordField.getMode(), comms::field::OptionalMode::Missing);
                    }

                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setConnectMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_DisconnectMsg(
        State& state,
        TestMsgHandler& handler)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setDisconnectMsgHandler(
                [&](const DisconnectMsg& msg)
                {
                    static_cast<void>(msg);
                    sent = true;
                    TS_TRACE("(BROKER) <-- DISCONNECT");
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setDisconnectMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_PingreqMsg(
        State& state,
        TestMsgHandler& handler)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPingreqMsgHandler(
                [&](const PingreqMsg& msg)
                {
                    static_cast<void>(msg);
                    sent = true;
                    TS_TRACE("(BROKER) <-- PINGREQ");
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setPingreqMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_PingrespMsg(
        State& state,
        TestMsgHandler& handler)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPingrespMsgHandler(
                [&](const PingrespMsg& msg)
                {
                    static_cast<void>(msg);
                    sent = true;
                    TS_TRACE("(BROKER) <-- PINGRESP");
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setPingrespMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_PublishMsg(
        State& state,
        TestMsgHandler& handler,
        const std::string& topic,
        const DataBuf& data,
        std::uint16_t packetId,
        mqtt::field::QosType qos,
        bool retain,
        bool dup)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPublishMsgHandler(
                [&](const PublishMsg& msg)
                {
                    sent = true;
                    TS_TRACE("(BROKER) <-- PUBLISH");
                    typedef PublishMsg MsgType;
                    auto& fields = msg.fields();
                    auto& flagsField = std::get<MsgType::FieldIdx_PublishFlags>(fields);
                    auto& flagsMembers = flagsField.value();
                    auto& retainField = std::get<mqtt::message::PublishActualFlagIdx_Retain>(flagsMembers);
                    auto& qosField = std::get<mqtt::message::PublishActualFlagIdx_QoS>(flagsMembers);
                    auto& dupField = std::get<mqtt::message::PublishActualFlagIdx_Dup>(flagsMembers);
                    auto& topicField = std::get<MsgType::FieldIdx_Topic>(fields);
                    auto& packetIdField = std::get<MsgType::FieldIdx_PacketId>(fields);
                    auto& payloadField = std::get<MsgType::FieldIdx_Payload>(fields);

                    TS_ASSERT_EQUALS(retainField.getBitValue(0), retain);
                    TS_ASSERT_EQUALS(qosField.value(), qos);
                    TS_ASSERT_EQUALS(dupField.getBitValue(0), dup);
                    TS_ASSERT_EQUALS(topicField.value(), topic);
                    TS_ASSERT_EQUALS(payloadField.value(), data);

                    if (qos == mqtt::field::QosType::AtMostOnceDelivery) {
                        TS_ASSERT_EQUALS(packetIdField.getMode(), comms::field::OptionalMode::Missing);
                    }
                    else {
                        TS_ASSERT_EQUALS(packetIdField.getMode(), comms::field::OptionalMode::Exists);
                        TS_ASSERT_EQUALS(packetIdField.field().value(), packetId);
                    }

                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setPublishMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_PubackMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t packetId)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPubackMsgHandler(
                [&](const PubackMsg& msg)
                {
                    sent = true;
                    TS_TRACE("(BROKER) <-- PUBACK");
                    typedef PubackMsg MsgType;
                    auto& fields = msg.fields();
                    auto& packetIdField = std::get<MsgType::FieldIdx_PacketId>(fields);

                    TS_ASSERT_EQUALS(packetIdField.value(), packetId);
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setPubackMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_PubrecMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t packetId)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPubrecMsgHandler(
                [&](const PubrecMsg& msg)
                {
                    sent = true;
                    TS_TRACE("(BROKER) <-- PUBREC");
                    typedef PubrecMsg MsgType;
                    auto& fields = msg.fields();
                    auto& packetIdField = std::get<MsgType::FieldIdx_PacketId>(fields);

                    TS_ASSERT_EQUALS(packetIdField.value(), packetId);
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setPubrecMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_PubrelMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t packetId)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPubrelMsgHandler(
                [&](const PubrelMsg& msg)
                {
                    sent = true;
                    TS_TRACE("(BROKER) <-- PUBREL");
                    typedef PubrecMsg MsgType;
                    auto& fields = msg.fields();
                    auto& packetIdField = std::get<MsgType::FieldIdx_PacketId>(fields);

                    TS_ASSERT_EQUALS(packetIdField.value(), packetId);
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setPubrelMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_PubcompMsg(
        State& state,
        TestMsgHandler& handler,
        std::uint16_t packetId)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setPubcompMsgHandler(
                [&](const PubcompMsg& msg)
                {
                    sent = true;
                    TS_TRACE("(BROKER) <-- PUBCOMP");
                    typedef PubcompMsg MsgType;
                    auto& fields = msg.fields();
                    auto& packetIdField = std::get<MsgType::FieldIdx_PacketId>(fields);

                    TS_ASSERT_EQUALS(packetIdField.value(), packetId);
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setPubcompMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_SubscribeMsg(
        State& state,
        TestMsgHandler& handler,
        const std::string& topic,
        mqtt::field::QosType qos,
        std::uint16_t packetId)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setSubscribeMsgHandler(
                [&](const SubscribeMsg& msg)
                {
                    sent = true;
                    TS_TRACE("(BROKER) <-- SUBSCRIBE");
                    typedef SubscribeMsg MsgType;
                    auto& fields = msg.fields();
                    auto& packetIdField = std::get<MsgType::FieldIdx_PacketId>(fields);
                    auto& payloadField = std::get<MsgType::FieldIdx_Payload>(fields);

                    TS_ASSERT(packetIdField.value() == packetId);
                    auto& payload = payloadField.value();
                    if (payload.empty()) {
                        TS_FAIL("Payload musn't be empty");
                        return;
                    }

                    auto& subElem = payload.front();
                    auto& subMembers = subElem.value();
                    auto& subTopicField = std::get<0>(subMembers);
                    auto& subQosField = std::get<1>(subMembers);

                    TS_ASSERT_EQUALS(subTopicField.value(), topic);
                    TS_ASSERT_EQUALS(subQosField.value(), qos);
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setSubscribeMsgHandler(std::move(oldCb));
    }

    static void verifySentToBroker_UnsubscribeMsg(
        State& state,
        TestMsgHandler& handler,
        const std::string& topic,
        std::uint16_t packetId)
    {
        if (state.m_sentToBroker.empty()) {
            TS_FAIL("No data was sent to broker");
            return;
        }

        bool sent = false;
        auto oldCb =
            handler.setUnsubscribeMsgHandler(
                [&](const UnsubscribeMsg& msg)
                {
                    sent = true;
                    TS_TRACE("(BROKER) <-- UNSUBSCRIBE");
                    typedef SubscribeMsg MsgType;
                    auto& fields = msg.fields();
                    auto& packetIdField = std::get<MsgType::FieldIdx_PacketId>(fields);
                    auto& payloadField = std::get<MsgType::FieldIdx_Payload>(fields);

                    TS_ASSERT_EQUALS(packetIdField.value(), packetId);
                    auto& payload = payloadField.value();
                    if (payload.empty()) {
                        TS_FAIL("Payload musn't be empty");
                        return;
                    }

                    auto& unsubStr = payload.front();

                    TS_ASSERT_EQUALS(unsubStr.value(), topic);
                });

        handler.processDataForBroker(state.m_sentToBroker.front());
        TS_ASSERT(sent);

        state.m_sentToBroker.pop_front();
        handler.setUnsubscribeMsgHandler(std::move(oldCb));
    }

    static void verifyBrokerReconnectReq(State& state)
    {
        if (state.m_brokerReconnectRequests.empty()) {
            TS_FAIL("No reconnect requests recorded");
            return;
        }

        TS_TRACE("[Reconnect]");
        state.m_brokerReconnectRequests.pop_front();
    }

    static void verifyTermReq(State& state)
    {
        if (state.m_termRequests.empty()) {
            TS_FAIL("No termination requests recorded");
            return;
        }

        TS_TRACE("[Term]");
        state.m_termRequests.pop_front();
    }

    static void verifyNoOtherEvent(State& state, TestMsgHandler& handler)
    {
        TS_ASSERT(state.m_sentToClient.empty());
        TS_ASSERT(state.m_sentToBroker.empty());
        TS_ASSERT(state.m_tickReq.empty());
        TS_ASSERT(state.m_elapsed.empty());
        TS_ASSERT(state.m_termRequests.empty());
        TS_ASSERT(state.m_brokerReconnectRequests.empty());

        while (!state.m_sentToClient.empty()) {
            handler.processDataForClient(state.m_sentToClient.front());
            state.m_sentToClient.pop_front();
        }

        while (!state.m_sentToBroker.empty()) {
            handler.processDataForBroker(state.m_sentToBroker.front());
            state.m_sentToBroker.pop_front();
        }

        while (!state.m_tickReq.empty()) {
            TS_TRACE("Unexpected tick req: " + std::to_string(state.m_tickReq.front()));
            state.m_tickReq.pop_front();
        }
    }

    static void verifyTickReq(State& state, unsigned value)
    {
        checkTickValue(state, value);
        if (!state.m_tickReq.empty()) {
            state.m_tickReq.pop_front();
        }
    }

    static mqttsn::protocol::field::QosType translateQos(mqtt::field::QosType val)
    {
        return static_cast<mqttsn::protocol::field::QosType>(val);
    }

    static mqtt::field::QosType translateQos(mqttsn::protocol::field::QosType val)
    {
        if (val == mqttsn::protocol::field::QosType::NoGwPublish) {
            return mqtt::field::QosType::AtMostOnceDelivery;
        }

        return static_cast<mqtt::field::QosType>(val);
    }

    static void doTick(State& state, mqttsn::gateway::Session& session, unsigned ms = 0)
    {
        if (ms != 0) {
            TS_TRACE("[TICK]: " + std::to_string(ms));
            TS_ASSERT(state.m_tickReq.size() <= 1U);
            state.m_tickReq.clear();
            session.tick(ms);
            return;
        }

        if (state.m_tickReq.empty()) {
            TS_FAIL("Tick wan't requested");
            return;
        }

        auto value = state.m_tickReq.front();
        TS_TRACE("[TICK]: " + std::to_string(value));
        state.m_tickReq.pop_front();
        session.tick(value);
    }

    static void doConnect(
        mqttsn::gateway::Session& session,
        State& state,
        TestMsgHandler& handler,
        WillInfo* willInfo = nullptr,
        bool cleanSession = true,
        bool expectReconnect = false,
        const std::string& username = std::string(),
        const DataBuf& pass = DataBuf())
    {
        bool hasWill = (willInfo != nullptr);
        auto connectMsg = handler.prepareClientConnect(DefaultClientId, DefaultKeepAlivePeriod, hasWill, cleanSession);
        dataFromClient(session, connectMsg, "CONNECT");

        if (hasWill) {
            verifySentToClient_WilltopicreqMsg(state, handler);
            verifyTickReq(state, DefaultRetryPeriod * 1000);
            verifyNoOtherEvent(state, handler);

            state.m_elapsed.push_back(1000);
            auto willtopicMsg = handler.prepareClientWilltopic(willInfo->m_topic, translateQos(willInfo->m_qos), willInfo->m_retain);
            dataFromClient(session, willtopicMsg, "WILLTOPIC");

            if (!willInfo->m_topic.empty()) {
                verifySentToClient_WillmsgreqMsg(state, handler);
                verifyTickReq(state, DefaultRetryPeriod * 1000);
                verifyNoOtherEvent(state, handler);

                state.m_elapsed.push_back(1000);
                auto willmsgMsg = handler.prepareClientWillmsg(willInfo->m_msg);
                dataFromClient(session, willmsgMsg, "WILLMSG");
            }
        }

        if (expectReconnect) {
            verifySentToBroker_DisconnectMsg(state, handler);
            verifyTickReq(state, DefaultRetryPeriod * 1000);
            verifyBrokerReconnectReq(state);
            verifyNoOtherEvent(state, handler);

            state.m_elapsed.push_back(1000);
            doBrokerDisconnect(session);
            verifyTickReq(state, DefaultRetryPeriod * 1000 - 1000);
            verifyNoOtherEvent(state, handler);

            state.m_elapsed.push_back(1000);
            doBrokerConnect(session);
        }

        verifySentToBroker_ConnectMsg(state, handler, DefaultClientId, DefaultKeepAlivePeriod, cleanSession, willInfo, username, pass);
        verifyNoOtherEvent(state, handler);

        auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted);
        dataFromBroker(session, connackMsg, "CONNACK");
        verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
        verifyNoOtherEvent(state, handler);
    }

    static void doBrokerConnect(mqttsn::gateway::Session& session)
    {
        session.setBrokerConnected(true);
        TS_TRACE("[BROKER connected]");
    }

    static void doBrokerDisconnect(mqttsn::gateway::Session& session)
    {
        session.setBrokerConnected(false);
        TS_TRACE("[BROKER disconnected]");
    }

};

const std::string SessionTest::DefaultClientId("client");

void SessionTest::test1()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    auto searchgwMsg = handler.prepareSearchgw();
    dataFromClient(*session, searchgwMsg, "SEARCHGW");
    verifySent_GwinfoMsg(state, handler, DefaultGwId);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test2()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string ClientId("bla");
    static const std::uint16_t KeepAlive = 60;
    static const bool CleanSession = true;
    auto connectMsg = handler.prepareClientConnect(ClientId, KeepAlive, false, CleanSession);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession);
    verifyNoOtherEvent(state, handler);

    auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted);
    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test3()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string ClientId("bla");
    static const std::uint16_t KeepAlive = 60;
    static const bool CleanSession = true;
    auto connectMsg = handler.prepareClientConnect(ClientId, KeepAlive, false, CleanSession);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession);
    verifyNoOtherEvent(state, handler);

    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession);
    verifyNoOtherEvent(state, handler);

    auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted);
    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);


    static const std::uint16_t KeepAlive2 = 120;
    static const bool CleanSession2 = false;

    auto connectMsg2 = handler.prepareClientConnect(ClientId, KeepAlive2, false, CleanSession2);
    dataFromClient(*session, connectMsg2, "CONNECT");
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyBrokerReconnectReq(state);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(500);
    doBrokerDisconnect(*session);
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 500);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    doBrokerConnect(*session);
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive2, CleanSession2);
    verifyNoOtherEvent(state, handler);

    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    static const std::string ClientId2 = "blablabla";
    auto connectMsg3 = handler.prepareClientConnect(ClientId2, KeepAlive, false, CleanSession);
    dataFromClient(*session, connectMsg3, "CONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test4()
{
    static const std::string Username("username");
    static const DataBuf Password = {'p', 'a', 's', 's'};
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler, DefaultGwId, &Username, &Password);

    static const std::string ClientId("blabla");
    static const std::uint16_t KeepAlive = 30;
    static const bool CleanSession = false;
    auto connectMsg = handler.prepareClientConnect(ClientId, KeepAlive, true, CleanSession);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToClient_WilltopicreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);

    static const std::string WillTopic("this/is/will");
    static const DataBuf WillMsg = {0, 1, 2, 3, 4, 5};
    static const auto WillQos = mqttsn::protocol::field::QosType::AtLeastOnceDelivery;
    static const bool WillRetain = false;

    state.m_elapsed.push_back(1000);
    auto willtopicMsg = handler.prepareClientWilltopic(WillTopic, WillQos, WillRetain);
    dataFromClient(*session, willtopicMsg, "WILLTOPIC");
    verifySentToClient_WillmsgreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);

    WillInfo willInfo;
    willInfo.m_topic = WillTopic;
    willInfo.m_msg = WillMsg;
    willInfo.m_qos = mqtt::field::QosType::AtLeastOnceDelivery;
    willInfo.m_retain = WillRetain;

    state.m_elapsed.push_back(1000);
    auto willmsgMsg = handler.prepareClientWillmsg(WillMsg);
    dataFromClient(*session, willmsgMsg, "WILLMSG");
    verifySentToBroker_ConnectMsg(state, handler, ClientId, KeepAlive, CleanSession, &willInfo, Username, Password);

    auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::BadUsernameOrPassword);
    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_NotSupported);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test5()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    auto disconnectSnMsg = handler.prepareClientDisconnect();
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);

    session = allocSession(state, handler);
    doConnect(*session, state, handler);

    auto disconnectMsg = handler.prepareBrokerDisconnect();
    dataFromBroker(*session, disconnectMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);

    session = allocSession(state, handler);
    doConnect(*session, state, handler);
    doBrokerDisconnect(*session);
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test6()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    static const std::uint16_t SleepDuration = 30 * 60;

    auto disconnectSnMsg = handler.prepareClientDisconnect(SleepDuration);
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    doTick(state, *session, DefaultRetryPeriod * 1000);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingrespMsg = handler.prepareBrokerPingresp();
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    auto expectedTickReq = DefaultKeepAlivePeriod * 1000 - 1000;
    verifyTickReq(state, expectedTickReq);
    verifyNoOtherEvent(state, handler);

    doTick(state, *session, expectedTickReq - 1000);
    verifyTickReq(state, 1000);
    verifyNoOtherEvent(state, handler);

    doTick(state, *session, 1000);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    verifyTickReq(state, expectedTickReq);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test7()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    static const std::uint16_t SleepDuration = 30 * 60;

    auto disconnectSnMsg = handler.prepareClientDisconnect(SleepDuration);
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingrespMsg = handler.prepareBrokerPingresp();
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    auto expectedTickReq = DefaultKeepAlivePeriod * 1000 - 1000;
    verifyTickReq(state, expectedTickReq);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(2000);
    auto connectMsg = handler.prepareClientConnect(DefaultClientId, DefaultKeepAlivePeriod, false, false);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test8()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string WillTopic("will/topic");
    static const DataBuf WillMsg = {0x1, 0x2, 0x3};
    static const auto WillQos = mqtt::field::QosType::AtMostOnceDelivery;
    static const bool WillRetain = false;
    WillInfo willInfo;
    willInfo.m_topic = WillTopic;
    willInfo.m_msg = WillMsg;
    willInfo.m_qos = WillQos;
    willInfo.m_retain = WillRetain;

    doConnect(*session, state, handler, &willInfo);

    static const std::uint16_t SleepDuration = 30 * 60;

    auto disconnectSnMsg = handler.prepareClientDisconnect(SleepDuration);
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingrespMsg = handler.prepareBrokerPingresp();
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    auto expectedTickReq = DefaultKeepAlivePeriod * 1000 - 1000;
    verifyTickReq(state, expectedTickReq);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(2000);
    auto connectMsg = handler.prepareClientConnect(DefaultClientId, DefaultKeepAlivePeriod * 2, false, false);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyBrokerReconnectReq(state);
    verifyTickReq(state, state.m_tickReq.front()); // remains from the asleep state.
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(500);
    doBrokerDisconnect(*session);
    verifyTickReq(state, state.m_tickReq.front()); // remains from the asleep state.
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(500);
    doBrokerConnect(*session);
    verifyTickReq(state, state.m_tickReq.front()); // remains from the asleep state.
    verifySentToBroker_ConnectMsg(state, handler, DefaultClientId, DefaultKeepAlivePeriod * 2, false, &willInfo);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto connackMsg = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted);
    dataFromBroker(*session, connackMsg, "CONNACK");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test9()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    static const std::string Topic("this/is/topic");
    static const std::uint16_t MsgId = 0x1122;
    auto registerMsg = handler.prepareClientRegister(Topic, MsgId);
    dataFromClient(*session, registerMsg, "REGISTER");
    auto topicId = verifySentToClient_RegackMsg(state, handler, MsgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    TS_ASSERT_LESS_THAN_EQUALS(DefaultMinTopicId, topicId);
    TS_ASSERT_LESS_THAN_EQUALS(topicId, DefaultMaxTopicId);
    verifyNoOtherEvent(state, handler);

    auto registerMsg2 = handler.prepareClientRegister(Topic, MsgId + 1);
    dataFromClient(*session, registerMsg2, "REGISTER");
    auto topicId2 = verifySentToClient_RegackMsg(state, handler, MsgId + 1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    TS_ASSERT_EQUALS(topicId, topicId2);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test10()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);
    static const std::string Topic1("this/is/topic1");
    static const std::uint16_t TopicId1 = 0x1111;


    session->addPredefinedTopic(Topic1, TopicId1);
    doConnect(*session, state, handler);

    static const std::string Topic2("this/is/topic2");
    static const std::uint16_t MsgId = 0x1122;
    auto registerMsg = handler.prepareClientRegister(Topic2, MsgId);
    dataFromClient(*session, registerMsg, "REGISTER");
    auto topicId = verifySentToClient_RegackMsg(state, handler, MsgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    TS_ASSERT_LESS_THAN_EQUALS(DefaultMinTopicId, topicId);
    TS_ASSERT_LESS_THAN_EQUALS(topicId, DefaultMaxTopicId);
    TS_ASSERT_DIFFERS(topicId, TopicId1);
    verifyNoOtherEvent(state, handler);

    auto registerMsg2 = handler.prepareClientRegister(Topic1, MsgId + 1);
    dataFromClient(*session, registerMsg2, "REGISTER");
    auto topicId2 = verifySentToClient_RegackMsg(state, handler, MsgId + 1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    TS_ASSERT_EQUALS(topicId2, TopicId1);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test11()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string Topic("topic");
    static const std::uint16_t TopicId = 0x1111;
    session->addPredefinedTopic(Topic, TopicId);

    doConnect(*session, state, handler);

    static const DataBuf Data = {0, 1, 2, 3, 4 };
    static const std::uint16_t MsgId = 1234;
    static const auto Qos = mqtt::field::QosType::AtMostOnceDelivery;
    static const bool Retain = false;
    static const bool Dup = false;
    auto publishMsg = handler.prepareBrokerPublish(Topic, Data, MsgId, Qos, Retain, Dup);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, Dup);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test12()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string Topic("topic");
    static const std::uint16_t TopicId = 0x1111;
    session->addPredefinedTopic(Topic, TopicId);

    doConnect(*session, state, handler);

    static const DataBuf Data = {0, 1, 2, 3, 4 };
    static const std::uint16_t MsgId = 1234;
    static const auto Qos = mqtt::field::QosType::AtLeastOnceDelivery;
    static const bool Retain = false;
    auto publishMsg = handler.prepareBrokerPublish(Topic, Data, MsgId, Qos, Retain, false);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifySentToBroker_PubackMsg(state, handler, MsgId);
    auto msgId = verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, false);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(2000);
    auto publishMsg2 = handler.prepareBrokerPublish(Topic, Data, MsgId, Qos, Retain, true);
    dataFromBroker(*session, publishMsg2, "PUBLISH");
    verifySentToBroker_PubackMsg(state, handler, MsgId);
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 2000);
    verifyNoOtherEvent(state, handler);

    doTick(state, *session, DefaultRetryPeriod * 1000 - 2000);
    auto msgId2 = verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, true);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);
    TS_ASSERT_EQUALS(msgId, msgId2);

    state.m_elapsed.push_back(1000);
    auto pubackMsg = handler.prepareClientPuback(TopicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromClient(*session, pubackMsg, "PUBACK");
    auto msgId3 = verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, true);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);
    TS_ASSERT_DIFFERS(msgId, msgId3);
}

void SessionTest::test13()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    static const std::string Topic("topic/bla/bla");
    static const DataBuf Data = {0, 1, 2, 3, 4};
    static const std::uint16_t MsgId = 0x1234;
    static const auto Qos = mqtt::field::QosType::ExactlyOnceDelivery;
    static const bool Retain = true;

    auto publishMsg = handler.prepareBrokerPublish(Topic, Data, MsgId, Qos, Retain, false);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifySentToBroker_PubrecMsg(state, handler, MsgId);
    verifyNoOtherEvent(state, handler);

    auto pubrelMsg = handler.prepareBrokerPubrel(MsgId);
    dataFromBroker(*session, pubrelMsg, "PUBREL");
    verifySentToBroker_PubcompMsg(state, handler, MsgId);
    verifySentToClient_RegisterMsg(state, handler, Topic);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    std::uint16_t topicId = 0U;
    std::uint16_t msgId = 0U;
    doTick(state, *session, DefaultRetryPeriod * 1000);
    std::tie(topicId, msgId) = verifySentToClient_RegisterMsg(state, handler, Topic);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto regackMsg = handler.prepareClientRegack(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromClient(*session, regackMsg, "REGACK");
    verifySentToClient_PublishMsg(state, handler, topicId, Data, mqttsn::protocol::field::TopicIdTypeVal::Normal, translateQos(Qos), Retain, false);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    std::uint16_t pubMsgId = 0U;
    doTick(state, *session, DefaultRetryPeriod * 1000);
    pubMsgId = verifySentToClient_PublishMsg(state, handler, topicId, Data, mqttsn::protocol::field::TopicIdTypeVal::Normal, translateQos(Qos), Retain, true);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pubrecMsg = handler.prepareClientPubrec(pubMsgId);
    dataFromClient(*session, pubrecMsg, "PUBREC");
    verifySentToClient_PubrelMsg(state, handler, pubMsgId);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    doTick(state, *session, DefaultRetryPeriod * 1000);
    verifySentToClient_PubrelMsg(state, handler, pubMsgId);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pubcompMsg = handler.prepareClientPubcomp(pubMsgId + 1);
    dataFromClient(*session, pubcompMsg, "PUBCOMP");
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    pubcompMsg = handler.prepareClientPubcomp(pubMsgId);
    dataFromClient(*session, pubcompMsg, "PUBCOMP");
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test14()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    static const std::string Topic("topic/bla/bla");
    static const DataBuf Data = {0, 1, 2, 3, 4};
    static const std::uint16_t MsgId = 0x1234;
    static const auto Qos = mqtt::field::QosType::AtMostOnceDelivery;
    static const bool Retain = true;

    auto publishMsg = handler.prepareBrokerPublish(Topic, Data, MsgId, Qos, Retain, false);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    std::uint16_t topicId = 0U;
    std::uint16_t msgId = 0U;
    std::tie(topicId, msgId) = verifySentToClient_RegisterMsg(state, handler, Topic);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto regackMsg = handler.prepareClientRegack(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromClient(*session, regackMsg, "REGACK");
    verifySentToClient_PublishMsg(state, handler, topicId, Data, mqttsn::protocol::field::TopicIdTypeVal::Normal, translateQos(Qos), Retain, false);
    verifyNoOtherEvent(state, handler);

    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifySentToClient_PublishMsg(state, handler, topicId, Data, mqttsn::protocol::field::TopicIdTypeVal::Normal, translateQos(Qos), Retain, false);
    verifyNoOtherEvent(state, handler);

    static const auto Qos2 = mqtt::field::QosType::AtLeastOnceDelivery;
    publishMsg = handler.prepareBrokerPublish(Topic, Data, MsgId, Qos2, Retain, false);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifySentToBroker_PubackMsg(state, handler, MsgId);
    msgId = verifySentToClient_PublishMsg(state, handler, topicId, Data, mqttsn::protocol::field::TopicIdTypeVal::Normal, translateQos(Qos2), Retain, false);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pubackMsg = handler.prepareClientPuback(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    dataFromClient(*session, pubackMsg, "PUBACK");
    std::tie(topicId, msgId) = verifySentToClient_RegisterMsg(state, handler, Topic);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    regackMsg = handler.prepareClientRegack(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromClient(*session, regackMsg, "REGACK");
    msgId = verifySentToClient_PublishMsg(state, handler, topicId, Data, mqttsn::protocol::field::TopicIdTypeVal::Normal, translateQos(Qos2), Retain, false);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    pubackMsg = handler.prepareClientPuback(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromClient(*session, pubackMsg, "PUBACK");
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test15()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    doConnect(*session, state, handler);

    static const std::string Topic("topic/bla/bla");
    static const DataBuf Data = {0, 1, 2, 3, 4};
    static const std::uint16_t MsgId = 0x1234;
    static const auto Qos = mqtt::field::QosType::AtLeastOnceDelivery;
    static const bool Retain = false;

    auto publishMsg = handler.prepareBrokerPublish(Topic, Data, MsgId, Qos, Retain, false);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifySentToBroker_PubackMsg(state, handler, MsgId);

    std::uint16_t topicId = 0U;
    std::uint16_t msgId = 0U;
    std::tie(topicId, msgId) = verifySentToClient_RegisterMsg(state, handler, Topic);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto regackMsg = handler.prepareClientRegack(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromClient(*session, regackMsg, "REGACK");
    msgId = verifySentToClient_PublishMsg(state, handler, topicId, Data, mqttsn::protocol::field::TopicIdTypeVal::Normal, translateQos(Qos), Retain, false);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pubackMsg = handler.prepareClientPuback(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    dataFromClient(*session, pubackMsg, "PUBACK");
    std::tie(topicId, msgId) = verifySentToClient_RegisterMsg(state, handler, Topic);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    regackMsg = handler.prepareClientRegack(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromClient(*session, regackMsg, "REGACK");
    msgId = verifySentToClient_PublishMsg(state, handler, topicId, Data, mqttsn::protocol::field::TopicIdTypeVal::Normal, translateQos(Qos), Retain, false);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    pubackMsg = handler.prepareClientPuback(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    dataFromClient(*session, pubackMsg, "PUBACK");
    std::tie(topicId, msgId) = verifySentToClient_RegisterMsg(state, handler, Topic);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    regackMsg = handler.prepareClientRegack(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromClient(*session, regackMsg, "REGACK");
    msgId = verifySentToClient_PublishMsg(state, handler, topicId, Data, mqttsn::protocol::field::TopicIdTypeVal::Normal, translateQos(Qos), Retain, false);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    pubackMsg = handler.prepareClientPuback(topicId, msgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    dataFromClient(*session, pubackMsg, "PUBACK");
    verifyNoOtherEvent(state, handler); // discarding the publish is expected
}

void SessionTest::test16()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string Topic("topic");
    static const std::uint16_t TopicId = 0x1111;
    session->addPredefinedTopic(Topic, TopicId);

    doConnect(*session, state, handler);

    static const std::uint16_t SleepDuration = 30 * 60;

    auto disconnectSnMsg = handler.prepareClientDisconnect(SleepDuration);
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingrespMsg = handler.prepareBrokerPingresp();
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 1000);
    verifyNoOtherEvent(state, handler);

    static const DataBuf Data = {0, 1, 2, 3, 4 };
    static const std::uint16_t MsgId = 1234;
    static const auto Qos = mqtt::field::QosType::AtMostOnceDelivery;
    static const bool Retain = false;

    state.m_elapsed.push_back(1000);
    auto publishMsg = handler.prepareBrokerPublish(Topic, Data, MsgId, Qos, Retain, false);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 2000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 3000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 4000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingreqMsg = handler.prepareClientPingreq(DefaultClientId);
    dataFromClient(*session, pingreqMsg, "PINGREQ");
    verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, false);
    verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, false);
    verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, false);
    verifySentToClient_PingrespMsg(state, handler);
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 5000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 6000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 7000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 8000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    doBrokerDisconnect(*session);
    verifyTickReq(state, ((SleepDuration * 3000) / 2) - 4000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto connectMsg = handler.prepareClientConnect(DefaultClientId, DefaultKeepAlivePeriod, false, false);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, false);
    verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, false);
    verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, false);
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test17()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string PredefinedTopic("predefined/topic");
    static const std::uint16_t PredefinedTopicId = 0x1111;
    session->addPredefinedTopic(PredefinedTopic, PredefinedTopicId);

    doConnect(*session, state, handler);

    static const std::string Topic("this/is/topic");
    static const std::uint16_t MsgId = 0x1122;
    auto registerMsg = handler.prepareClientRegister(Topic, MsgId);
    dataFromClient(*session, registerMsg, "REGISTER");
    auto topicId = verifySentToClient_RegackMsg(state, handler, MsgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    TS_ASSERT_LESS_THAN_EQUALS(DefaultMinTopicId, topicId);
    TS_ASSERT_LESS_THAN_EQUALS(topicId, DefaultMaxTopicId);
    verifyNoOtherEvent(state, handler);


    static const DataBuf Data = {0, 1, 2, 3, 4, 5, 6};
    static const auto Qos = mqttsn::protocol::field::QosType::AtLeastOnceDelivery;
    static const bool Retain = false;

    auto publishMsg = handler.prepareClientPublish(Data, topicId + 1, MsgId, mqttsn::protocol::field::TopicIdTypeVal::Normal, Qos, Retain, false);
    dataFromClient(*session, publishMsg, "PUBLISH");
    verifySentToClient_PubackMsg(state, handler, topicId + 1, MsgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    verifyNoOtherEvent(state, handler);

    publishMsg = handler.prepareClientPublish(Data, topicId, MsgId, mqttsn::protocol::field::TopicIdTypeVal::Normal, Qos, Retain, false);
    dataFromClient(*session, publishMsg, "PUBLISH");
    verifySentToBroker_PublishMsg(state, handler, Topic, Data, MsgId, translateQos(Qos), Retain, false);
    verifyNoOtherEvent(state, handler);

    auto pubackMsg = handler.prepareBrokerPuback(MsgId);
    dataFromBroker(*session, pubackMsg, "PUBACK");
    verifySentToClient_PubackMsg(state, handler, topicId, MsgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    static const std::uint16_t SleepDuration = 30 * 60;
    auto disconnectSnMsg = handler.prepareClientDisconnect(SleepDuration);
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingrespMsg = handler.prepareBrokerPingresp();
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    auto expectedTickReq = DefaultKeepAlivePeriod * 1000 - 1000;
    verifyTickReq(state, expectedTickReq);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto connectMsg = handler.prepareClientConnect(DefaultClientId, DefaultKeepAlivePeriod, false, true);
    dataFromClient(*session, connectMsg, "CONNECT");
    verifySentToClient_ConnackMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyNoOtherEvent(state, handler);

    dataFromClient(*session, publishMsg, "PUBLISH");
    verifySentToClient_PubackMsg(state, handler, topicId, MsgId, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    verifyNoOtherEvent(state, handler);

    publishMsg = handler.prepareClientPublish(Data, PredefinedTopicId, MsgId, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, Qos, Retain, false);
    dataFromClient(*session, publishMsg, "PUBLISH");
    verifySentToBroker_PublishMsg(state, handler, PredefinedTopic, Data, MsgId, translateQos(Qos), Retain, false);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test18()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string PredefinedTopic("predefined/topic");
    static const std::uint16_t PredefinedTopicId = 0x1111;
    session->addPredefinedTopic(PredefinedTopic, PredefinedTopicId);

    doConnect(*session, state, handler);

    static const std::string Topic("this/is/topic");
    static const std::uint16_t MsgId = 0x1122;
    auto registerMsg = handler.prepareClientRegister(Topic, MsgId);
    dataFromClient(*session, registerMsg, "REGISTER");
    auto topicId = verifySentToClient_RegackMsg(state, handler, MsgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    TS_ASSERT_LESS_THAN_EQUALS(DefaultMinTopicId, topicId);
    TS_ASSERT_LESS_THAN_EQUALS(topicId, DefaultMaxTopicId);
    verifyNoOtherEvent(state, handler);

    static const DataBuf Data = {0, 1, 2, 3, 4, 5, 6};
    static const auto Qos1 = mqttsn::protocol::field::QosType::AtLeastOnceDelivery;
    static const auto Qos2 = mqttsn::protocol::field::QosType::ExactlyOnceDelivery;
    static const bool Retain = false;

    auto publishMsg = handler.prepareClientPublish(Data, topicId, MsgId, mqttsn::protocol::field::TopicIdTypeVal::Normal, Qos1, Retain, false);
    dataFromClient(*session, publishMsg, "PUBLISH");
    verifySentToBroker_PublishMsg(state, handler, Topic, Data, MsgId, translateQos(Qos1), Retain, false);
    verifyNoOtherEvent(state, handler);

    auto pubackMsg = handler.prepareBrokerPuback(MsgId);
    dataFromBroker(*session, pubackMsg, "PUBACK");
    verifySentToClient_PubackMsg(state, handler, topicId, MsgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    publishMsg = handler.prepareClientPublish(Data, PredefinedTopicId, MsgId, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, Qos2, Retain, true);
    dataFromClient(*session, publishMsg, "PUBLISH");
    verifySentToBroker_PublishMsg(state, handler, PredefinedTopic, Data, MsgId, translateQos(Qos2), Retain, true);
    verifyNoOtherEvent(state, handler);

    auto pubrecMsg = handler.prepareBrokerPubrec(MsgId);
    dataFromBroker(*session, pubrecMsg, "PUBREC");
    verifySentToClient_PubrecMsg(state, handler, MsgId);
    verifyNoOtherEvent(state, handler);

    auto pubrelMsg = handler.prepareClientPubrel(MsgId);
    dataFromClient(*session, pubrelMsg, "PUBREL");
    verifySentToBroker_PubrelMsg(state, handler, MsgId);
    verifyNoOtherEvent(state, handler);

    auto pubcompMsg = handler.prepareBrokerPubcomp(MsgId);
    dataFromBroker(*session, pubcompMsg, "PUBCOMP");
    verifySentToClient_PubcompMsg(state, handler, MsgId);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test19()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string Topic("predefined/topic");
    static const std::uint16_t TopicId = 0x1111;
    session->addPredefinedTopic(Topic, TopicId);

    doConnect(*session, state, handler);

    static const DataBuf Data1 = {0, 1, 2, 3, 4, 5, 6};
    static const DataBuf Data2 = {10, 11, 12, 13, 14, 15, 16};
    static const DataBuf Data3 = {20, 21, 22, 23, 24, 25, 26};
    static const DataBuf Data4 = {30, 31, 32, 33, 34, 35, 36};
    static const auto Qos0 = mqtt::field::QosType::AtMostOnceDelivery;
    static const auto Qos1 = mqtt::field::QosType::AtLeastOnceDelivery;
    static const auto Qos2 = mqtt::field::QosType::ExactlyOnceDelivery;
    static const bool Retain = true;
    static const bool Dup = false;

    static const uint16_t MsgId1 = 0x1111;
    static const uint16_t MsgId2 = 0x2222;
    static const uint16_t MsgId3 = 0x3333;
    static const uint16_t MsgId4 = 0x4444;

    auto pub1 = handler.prepareBrokerPublish(Topic, Data1, MsgId1, Qos2, Retain, Dup);
    dataFromBroker(*session, pub1, "PUBLISH");
    verifySentToBroker_PubrecMsg(state, handler, MsgId1);
    verifyNoOtherEvent(state, handler);

    auto pub2 = handler.prepareBrokerPublish(Topic, Data2, MsgId2, Qos1, Retain, Dup);
    dataFromBroker(*session, pub2, "PUBLISH");
    verifySentToBroker_PubackMsg(state, handler, MsgId2);
    auto msgId1 = verifySentToClient_PublishMsg(state, handler, TopicId, Data2, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos1), Retain, Dup);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pub3 = handler.prepareBrokerPublish(Topic, Data3, MsgId3, Qos0, Retain, Dup);
    dataFromBroker(*session, pub3, "PUBLISH");
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pub4 = handler.prepareBrokerPublish(Topic, Data4, MsgId4, Qos2, Retain, Dup);
    dataFromBroker(*session, pub4, "PUBLISH");
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 2000);
    verifySentToBroker_PubrecMsg(state, handler, MsgId4);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto ack1 = handler.prepareClientPuback(TopicId, msgId1, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    dataFromClient(*session, ack1, "PUBACK");
    verifySentToClient_PublishMsg(state, handler, TopicId, Data3, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos0), Retain, Dup);
    verifyNoOtherEvent(state, handler);

    auto b_rec = handler.prepareBrokerPubrel(MsgId1);
    dataFromBroker(*session, b_rec, "PUBREC");
    verifySentToBroker_PubcompMsg(state, handler, MsgId1);
    auto msgId2 = verifySentToClient_PublishMsg(state, handler, TopicId, Data1, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos2), Retain, Dup);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto b_rec2 = handler.prepareBrokerPubrel(MsgId4);
    dataFromBroker(*session, b_rec2, "PUBREC");
    verifySentToBroker_PubcompMsg(state, handler, MsgId4);
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto rec2 = handler.prepareClientPubrec(msgId2);
    dataFromClient(*session, rec2, "PUBREC");
    verifySentToClient_PubrelMsg(state, handler, msgId2);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto comp = handler.prepareClientPubcomp(msgId2);
    dataFromClient(*session, comp, "PUBCOMP");
    auto msgId3 = verifySentToClient_PublishMsg(state, handler, TopicId, Data4, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos2), Retain, Dup);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto rec3 = handler.prepareClientPubrec(msgId3);
    dataFromClient(*session, rec3, "PUBREC");
    verifySentToClient_PubrelMsg(state, handler, msgId3);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto comp2 = handler.prepareClientPubcomp(msgId3);
    dataFromClient(*session, comp2, "PUBCOMP");
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test20()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    auto cReq = handler.prepareClientPingreq();
    dataFromClient(*session, cReq, "PINGRESP");
    verifyNoOtherEvent(state, handler);

    doConnect(*session, state, handler);

    dataFromClient(*session, cReq, "PINGREQ");
    verifySentToBroker_PingreqMsg(state, handler);
    verifyNoOtherEvent(state, handler);

    auto bResp = handler.prepareBrokerPingresp();
    dataFromBroker(*session, bResp, "PINGRESP");
    verifySentToClient_PingrespMsg(state, handler);
    verifyNoOtherEvent(state, handler);

    auto bReq = handler.prepareBrokerPingreq();
    dataFromBroker(*session, bReq, "PINGREQ");
    verifySentToClient_PingreqMsg(state, handler);
    verifyNoOtherEvent(state, handler);

    auto cResp = handler.prepareClientPingresp();
    dataFromClient(*session, cResp, "PINGRESP");
    verifySentToBroker_PingrespMsg(state, handler);
    verifyNoOtherEvent(state, handler);

    // should be ignored
    dataFromBroker(*session, bResp, "PINGRESP");
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test21()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string PredefinedTopic("predefined/topic");
    static const std::uint16_t PredefinedTopicId = 0x1111;
    session->addPredefinedTopic(PredefinedTopic, PredefinedTopicId);

    doConnect(*session, state, handler);

    static const auto Qos = mqttsn::protocol::field::QosType::ExactlyOnceDelivery;
    static const std::uint16_t SubMsgId1 = 0x1234;
    auto subMsg1 = handler.prepareClientSubscribe(PredefinedTopicId, SubMsgId1, Qos, true);
    dataFromClient(*session, subMsg1, "SUBSCRIBE");
    verifySentToBroker_SubscribeMsg(state, handler, PredefinedTopic, translateQos(Qos), SubMsgId1);
    verifyNoOtherEvent(state, handler);

    auto subackMsg1 = handler.prepareBrokerSuback(SubMsgId1, mqtt::message::SubackReturnCode::SuccessQos2);
    dataFromBroker(*session, subackMsg1, "SUBACK");
    verifySentToClient_SubackMsg(state, handler, PredefinedTopicId, SubMsgId1, Qos, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    static const std::string Topic("this/is/topic");
    static const std::uint16_t TopicId = 0x2222;
    static const std::uint16_t SubMsgId2 = 0x5555;
    auto subMsg2 = handler.prepareClientSubscribe(TopicId, SubMsgId2, Qos, false);
    dataFromClient(*session, subMsg2, "SUBSCRIBE");
    verifySentToClient_SubackMsg(state, handler, TopicId, SubMsgId2, Qos, mqttsn::protocol::field::ReturnCodeVal_InvalidTopicId);
    verifyNoOtherEvent(state, handler);

    static const std::uint16_t RegMsgId = 0x5556;
    auto registerMsg = handler.prepareClientRegister(Topic, RegMsgId);
    dataFromClient(*session, registerMsg, "REGISTER");
    auto topicId = verifySentToClient_RegackMsg(state, handler, RegMsgId, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    TS_ASSERT_LESS_THAN_EQUALS(DefaultMinTopicId, topicId);
    TS_ASSERT_LESS_THAN_EQUALS(topicId, DefaultMaxTopicId);
    verifyNoOtherEvent(state, handler);

    static const std::uint16_t SubMsgId3 = 0x5557;
    auto subMsg3 = handler.prepareClientSubscribe(topicId, SubMsgId3, Qos, false);
    dataFromClient(*session, subMsg3, "SUBSCRIBE");
    verifySentToBroker_SubscribeMsg(state, handler, Topic, translateQos(Qos), SubMsgId3);
    verifyNoOtherEvent(state, handler);

    auto subackMsg2 = handler.prepareBrokerSuback(SubMsgId3, mqtt::message::SubackReturnCode::SuccessQos1);
    dataFromBroker(*session, subackMsg2, "SUBACK");
    verifySentToClient_SubackMsg(state, handler, topicId, SubMsgId3, mqttsn::protocol::field::QosType::AtLeastOnceDelivery, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    static const std::uint16_t SubMsgId4 = 0x6000;
    auto subMsg4 = handler.prepareClientSubscribe(Topic, SubMsgId4, Qos);
    dataFromClient(*session, subMsg4, "SUBSCRIBE");
    verifySentToBroker_SubscribeMsg(state, handler, Topic, translateQos(Qos), SubMsgId4);
    verifyNoOtherEvent(state, handler);

    auto subackMsg3 = handler.prepareBrokerSuback(SubMsgId4, mqtt::message::SubackReturnCode::SuccessQos2);
    dataFromBroker(*session, subackMsg3, "SUBACK");
    verifySentToClient_SubackMsg(state, handler, topicId, SubMsgId4, Qos, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    static const std::uint16_t UnsubMsgId1 = 0x0001;
    auto unsubMsg1 = handler.prepareClientUnsubscribe(PredefinedTopicId, UnsubMsgId1, true);
    dataFromClient(*session, unsubMsg1, "UNSUBSCRIBE");
    verifySentToBroker_UnsubscribeMsg(state, handler, PredefinedTopic, UnsubMsgId1);
    verifyNoOtherEvent(state, handler);

    auto unsubackMsg1 = handler.prepareBrokerUnsuback(UnsubMsgId1);
    dataFromBroker(*session, unsubackMsg1, "UNSUBACK");
    verifySentToClient_UnsubackMsg(state, handler, UnsubMsgId1);
    verifyNoOtherEvent(state, handler);

    static const std::uint16_t UnsubMsgId2 = 0x0002;
    auto unsubMsg2 = handler.prepareClientUnsubscribe(TopicId, UnsubMsgId2,  false);
    dataFromClient(*session, unsubMsg2, "UNSUBSCRIBE");
    verifyNoOtherEvent(state, handler);

    static const std::uint16_t UnsubMsgId3 = 0x0003;
    auto unsubMsg3 = handler.prepareClientUnsubscribe(topicId, UnsubMsgId3, false);
    dataFromClient(*session, unsubMsg3, "UNSUBSCRIBE");
    verifySentToBroker_UnsubscribeMsg(state, handler, Topic, UnsubMsgId3);
    verifyNoOtherEvent(state, handler);

    auto unsubackMsg2 = handler.prepareBrokerUnsuback(UnsubMsgId3);
    dataFromBroker(*session, unsubackMsg2, "UNSUBACK");
    verifySentToClient_UnsubackMsg(state, handler, UnsubMsgId3);
    verifyNoOtherEvent(state, handler);

    static const std::uint16_t UnsubMsgId4 = 0x0004;
    auto unsubMsg4 = handler.prepareClientUnsubscribe(Topic, UnsubMsgId4);
    dataFromClient(*session, unsubMsg4, "UNSUBSCRIBE");
    verifySentToBroker_UnsubscribeMsg(state, handler, Topic, UnsubMsgId4);
    verifyNoOtherEvent(state, handler);

    auto unsubackMsg3 = handler.prepareBrokerUnsuback(UnsubMsgId4);
    dataFromBroker(*session, unsubackMsg3, "UNSUBACK");
    verifySentToClient_UnsubackMsg(state, handler, UnsubMsgId4);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test22()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);

    static const std::string WillTopic1("will/topic/1");
    static const DataBuf WillData1 = {0, 1, 2};
    static const auto WillQos1 = mqtt::field::QosType::AtLeastOnceDelivery;
    static const bool WillRetain1 = true;
    WillInfo will1;
    will1.m_topic = WillTopic1;
    will1.m_msg = WillData1;
    will1.m_qos = WillQos1;
    will1.m_retain = WillRetain1;


    doConnect(*session, state, handler, &will1);
    verifyNoOtherEvent(state, handler);

    WillInfo will2;
    doConnect(*session, state, handler, &will2, false, true);
}

void SessionTest::test23()
{
    static const std::string Username = "username";
    static const DataBuf Pass = {'p', 'a', 's', 's'};
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler, DefaultGwId, &Username, &Pass);

    static const std::string WillTopic1("will/topic/1");
    static const DataBuf WillData1 = {0, 1, 2};
    static const auto WillQos1 = mqtt::field::QosType::AtLeastOnceDelivery;
    static const bool WillRetain1 = true;
    WillInfo will1;
    will1.m_topic = WillTopic1;
    will1.m_msg = WillData1;
    will1.m_qos = WillQos1;
    will1.m_retain = WillRetain1;

    doConnect(*session, state, handler, &will1, true, false, Username, Pass);
    verifyNoOtherEvent(state, handler);

    auto willTopicUpdMsg1 = handler.prepareClientWilltopicupd(WillTopic1, translateQos(WillQos1), WillRetain1);
    dataFromClient(*session, willTopicUpdMsg1, "WILLTOPICUPD");
    verifySentToClient_WilltopicrespMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);

    static const std::string WillTopic2("will/topic/2");
    auto willTopicUpdMsg2 = handler.prepareClientWilltopicupd(WillTopic2, translateQos(WillQos1), WillRetain1);
    dataFromClient(*session, willTopicUpdMsg2, "WILLTOPICUPD");
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyBrokerReconnectReq(state);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    doBrokerDisconnect(*session);
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 1000);
    verifyNoOtherEvent(state, handler);

    WillInfo updWillInfo;
    updWillInfo.m_topic = WillTopic2;
    updWillInfo.m_msg = WillData1;
    updWillInfo.m_qos = WillQos1;
    updWillInfo.m_retain = WillRetain1;
    state.m_elapsed.push_back(1000);
    doBrokerConnect(*session);
    verifySentToBroker_ConnectMsg(state, handler, DefaultClientId, DefaultKeepAlivePeriod, false, &updWillInfo, Username, Pass);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto connackMsg1 = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted, true);
    dataFromBroker(*session, connackMsg1, "CONNACK");
    verifySentToClient_WilltopicrespMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    static const auto WillQos2 = mqtt::field::QosType::ExactlyOnceDelivery;
    auto willTopicUpdMsg3 = handler.prepareClientWilltopicupd(WillTopic2, translateQos(WillQos2), WillRetain1);
    dataFromClient(*session, willTopicUpdMsg3, "WILLTOPICUPD");
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyBrokerReconnectReq(state);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    doBrokerDisconnect(*session);
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 1000);
    verifyNoOtherEvent(state, handler);

    updWillInfo.m_topic = WillTopic2;
    updWillInfo.m_msg = WillData1;
    updWillInfo.m_qos = WillQos2;
    updWillInfo.m_retain = WillRetain1;
    state.m_elapsed.push_back(1000);
    doBrokerConnect(*session);
    verifySentToBroker_ConnectMsg(state, handler, DefaultClientId, DefaultKeepAlivePeriod, false, &updWillInfo, Username, Pass);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto connackMsg2 = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::BadUsernameOrPassword, false);
    dataFromBroker(*session, connackMsg2, "CONNACK");
    verifySentToClient_WilltopicrespMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_NotSupported);
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);

    session = allocSession(state, handler);

    dataFromClient(*session, willTopicUpdMsg1, "WILLTOPICUPD");
    verifySentToClient_WilltopicrespMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_NotSupported);
    verifyNoOtherEvent(state, handler);

    doConnect(*session, state, handler, &will1);
    verifyNoOtherEvent(state, handler);

    auto willTopicUpdMsg4 = handler.prepareClientWilltopicupd(WillTopic1, translateQos(WillQos1), !WillRetain1);
    dataFromClient(*session, willTopicUpdMsg4, "WILLTOPICUPD");
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyBrokerReconnectReq(state);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    doBrokerDisconnect(*session);
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 1000);
    verifyNoOtherEvent(state, handler);

    updWillInfo = will1;
    updWillInfo.m_retain = !WillRetain1;
    state.m_elapsed.push_back(1000);
    doBrokerConnect(*session);
    verifySentToBroker_ConnectMsg(state, handler, DefaultClientId, DefaultKeepAlivePeriod, false, &updWillInfo);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    doTick(state, *session, DefaultRetryPeriod * 1000);
    verifySentToClient_WilltopicrespMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_NotSupported);
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test24()
{
    static const std::string Username = "username";
    static const DataBuf Pass = {'p', 'a', 's', 's'};
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler, DefaultGwId, &Username, &Pass);

    static const std::string WillTopic("will/topic");
    static const DataBuf WillData1 = {0, 1, 2};
    static const auto WillQos = mqtt::field::QosType::AtLeastOnceDelivery;
    static const bool WillRetain = true;

    WillInfo will;
    will.m_topic = WillTopic;
    will.m_msg = WillData1;
    will.m_qos = WillQos;
    will.m_retain = WillRetain;

    doConnect(*session, state, handler, &will, true, false, Username, Pass);
    verifyNoOtherEvent(state, handler);

    auto willMsgUpdMsg1 = handler.prepareClientWillmsgupd(WillData1);
    dataFromClient(*session, willMsgUpdMsg1, "WILLMSGUPD");
    verifySentToClient_WillmsgrespMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);

    static const DataBuf WillData2 = {10, 11, 12};
    auto willMsgUpdMsg2 = handler.prepareClientWillmsgupd(WillData2);
    dataFromClient(*session, willMsgUpdMsg2, "WILLMSGUPD");
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyBrokerReconnectReq(state);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    doBrokerDisconnect(*session);
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 1000);
    verifyNoOtherEvent(state, handler);

    will.m_msg = WillData2;
    state.m_elapsed.push_back(1000);
    doBrokerConnect(*session);
    verifySentToBroker_ConnectMsg(state, handler, DefaultClientId, DefaultKeepAlivePeriod, false, &will, Username, Pass);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto connackMsg1 = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted, true);
    dataFromBroker(*session, connackMsg1, "CONNACK");
    verifySentToClient_WillmsgrespMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_Accepted);
    verifyNoOtherEvent(state, handler);

    dataFromClient(*session, willMsgUpdMsg1, "WILLMSGUPD");
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyBrokerReconnectReq(state);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    doBrokerDisconnect(*session);
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 1000);
    verifyNoOtherEvent(state, handler);

    will.m_msg = WillData1;
    state.m_elapsed.push_back(1000);
    doBrokerConnect(*session);
    verifySentToBroker_ConnectMsg(state, handler, DefaultClientId, DefaultKeepAlivePeriod, false, &will, Username, Pass);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto connackMsg2 = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::Accepted, false);
    dataFromBroker(*session, connackMsg2, "CONNACK");
    verifySentToClient_WillmsgrespMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_NotSupported);
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);

    session = allocSession(state, handler);
    doConnect(*session, state, handler, &will);

    dataFromClient(*session, willMsgUpdMsg2, "WILLMSGUPD");
    verifySentToBroker_DisconnectMsg(state, handler);
    verifyBrokerReconnectReq(state);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    doBrokerDisconnect(*session);
    verifyTickReq(state, DefaultRetryPeriod * 1000 - 1000);
    verifyNoOtherEvent(state, handler);

    will.m_msg = WillData2;
    state.m_elapsed.push_back(1000);
    doBrokerConnect(*session);
    verifySentToBroker_ConnectMsg(state, handler, DefaultClientId, DefaultKeepAlivePeriod, false, &will);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto connackMsg3 = handler.prepareBrokerConnack(mqtt::message::ConnackResponseCode::NotAuthorized, false);
    dataFromBroker(*session, connackMsg3, "CONNACK");
    verifySentToClient_WillmsgrespMsg(state, handler, mqttsn::protocol::field::ReturnCodeVal_NotSupported);
    verifySentToClient_DisconnectMsg(state, handler);
    verifyTermReq(state);
    verifyNoOtherEvent(state, handler);
}

void SessionTest::test25()
{
    TestMsgHandler handler;
    State state;
    auto session = allocSession(state, handler);
    static const std::string Topic("topic");
    static const std::uint16_t TopicId = 0x1111;
    session->addPredefinedTopic(Topic, TopicId);
    session->setSleepingClientMsgLimit(3U);

    doConnect(*session, state, handler);

    static const std::uint16_t SleepDuration = 30 * 60;

    auto disconnectSnMsg = handler.prepareClientDisconnect(SleepDuration);
    dataFromClient(*session, disconnectSnMsg, "DISCONNECT");
    verifySentToClient_DisconnectMsg(state, handler);
    verifySentToBroker_PingreqMsg(state, handler);
    verifyTickReq(state, DefaultRetryPeriod * 1000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingrespMsg = handler.prepareBrokerPingresp();
    dataFromBroker(*session, pingrespMsg, "PINGRESP");
    auto expectedTickReq = DefaultKeepAlivePeriod * 1000 - 1000;
    verifyTickReq(state, expectedTickReq);
    verifyNoOtherEvent(state, handler);

    static const DataBuf Data = {0, 1, 2, 3, 4 };
    static const std::uint16_t MsgId = 1234;
    static const auto Qos = mqtt::field::QosType::AtMostOnceDelivery;
    static const bool Retain = false;

    state.m_elapsed.push_back(1000);
    auto publishMsg = handler.prepareBrokerPublish(Topic, Data, MsgId, Qos, Retain, false);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 2000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 3000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 4000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    dataFromBroker(*session, publishMsg, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 5000);
    verifyNoOtherEvent(state, handler);

    static const DataBuf Data2 = {0, 1, 2, 3, 4, 10};
    state.m_elapsed.push_back(1000);
    auto publishMsg2 = handler.prepareBrokerPublish(Topic, Data2, MsgId, Qos, Retain, false);
    dataFromBroker(*session, publishMsg2, "PUBLISH");
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 6000);
    verifyNoOtherEvent(state, handler);

    state.m_elapsed.push_back(1000);
    auto pingreqMsg = handler.prepareClientPingreq(DefaultClientId);
    dataFromClient(*session, pingreqMsg, "PINGREQ");
    verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, false);
    verifySentToClient_PublishMsg(state, handler, TopicId, Data, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, false);
    verifySentToClient_PublishMsg(state, handler, TopicId, Data2, mqttsn::protocol::field::TopicIdTypeVal::PreDefined, translateQos(Qos), Retain, false);
    verifySentToClient_PingrespMsg(state, handler);
    verifyTickReq(state, DefaultKeepAlivePeriod * 1000 - 7000);
    verifyNoOtherEvent(state, handler);
}

// TODO: test qos=-1 publishes.
